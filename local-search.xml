<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>epoll浅析</title>
    <link href="/WennyAhhh.github.io/2020/12/10/epoll%E6%B5%85%E6%9E%90/"/>
    <url>/WennyAhhh.github.io/2020/12/10/epoll%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="epoll浅析"><a href="#epoll浅析" class="headerlink" title="epoll浅析"></a>epoll浅析</h1><blockquote><p>承接上次写的博客，阻塞和非阻塞的那一部分，最开始是源于对epoll工作模式的疑惑。在看了很多大佬的博文和epoll的源码之后，整理了一下epoll的基本工作方式和用法。</p><p>网上的博客良莠不齐，需要自己思考才能有所收获。（当然我这篇也只是我的个人见解，没有什么权威性，千万不要把我下面尤其是括号中的东西当做真真确确的东西。</p></blockquote><h2 id="epoll系列系统调用"><a href="#epoll系列系统调用" class="headerlink" title="epoll系列系统调用"></a>epoll系列系统调用</h2><p>epoll主要是下面三个函数。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;says/epoll.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">( 内核事件的大小 )</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">( 内核事件表的文件描述符，操作类型（添加，修改，删除），添加用户关系的文件描述符，事件类型)</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">( 内核事件表的文件描述符，就绪事件数组，最多监听多少个事件，阻塞时间)</span></span></code></pre><p>epoll_create 用于<strong>创建</strong>一个内核事件表的文件描述符，一般一个程序只创建一个<br>epoll_ctl   用于<strong>操作</strong>用户关心的文件描述符。其中的<code>op</code>参数</p><table><thead><tr><th align="center">EPOLL_CTL_ADD</th><th>添加</th></tr></thead><tbody><tr><td align="center">EPOLL_CTL_MOD</td><td>修改</td></tr><tr><td align="center">EPOLL_CTL_DEL</td><td>删除</td></tr></tbody></table><p>epoll_wait 它在一段<strong>超时等待</strong>事件内等待一组文件描述符上的事件。就是当IO事件的第一个阶段完成，文件描述符转化为就绪事件，就会触发这个函数。其中的细节后续再谈，</p><p>epoll相对于poll和select，将触发就绪事件和注册事件分开。观察最常使用的<code>epoll_wait()</code>,就会发现：就绪事件，也就是第二个参数，是从函数内部通过指针传递过来的，相对而言入参很少。这样就避免了<code>select/poll</code>每次调用都要重新加入文件描述符/事件数组。</p><p><code>select/pol</code>l每次都会返回全部的事件数组，但是其中还包括了没有就绪的事件，这个是我们不需要处理的。所以他们寻找就绪事件的事件复杂度为<code>O(n)</code>。<br>epoll返回的都是就绪事件，他寻找就绪事件的事件复杂度为<code>O(1)</code>。</p><h2 id="概念和主要数据结构"><a href="#概念和主要数据结构" class="headerlink" title="概念和主要数据结构"></a>概念和主要数据结构</h2><p>在学习epoll的时候，我困惑于书上的一句话</p><blockquote><p>epoll_wait则不同，他采用的是回调的方式。内核监测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。</p></blockquote><p>既然触发了回调函数，那么epoll不是异步的么？那为什么说epoll是同步？</p><p>回答此问题需要明白epoll的工作原理。我们需要一些了解一些东西。</p><h3 id="同步，异步"><a href="#同步，异步" class="headerlink" title="同步，异步"></a>同步，异步</h3><p>同步异步在另外的博客中提到过，不再赘述.</p><h3 id="mmap-epoll源码中没有使用"><a href="#mmap-epoll源码中没有使用" class="headerlink" title="mmap(epoll源码中没有使用)"></a>mmap(epoll源码中没有使用)</h3><p>(申请一块内存，将内核态内存映射到用户态，应该是从链表中的数据映射到数组中，避免copy操作。<del>但是仔细思考过又觉得很别扭。查看<code>mmap</code>函数，他需要传递一个文件描述符，这个文件描述符是需要映射的文件。但是在<code>epoll_wait</code>中，需要映射的空间是一个链表，里面包含多个文件描述符，但是<code>epoll_wait</code>只提供一个地址。这样问题就复杂起来了</del>，于是去查了一下这个问题，<strong>才发现！！！ epoll根本没有用mmap技术！</strong>，现在细品在侯捷老师那边听到的– <strong>源码面前了无秘密</strong>。感触良深）</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>用于在内核空间添加一个事件表，添加用户所关系的事件。对于普通的数组来说，一个文件描述符的插入或者删除操作，时间复杂度可以达到O(logN)。(至于为什么不用O(1)的哈希表?可能是因为像STL库中乘2太浪费空间时间了？如果不是这样操作，如果产生冲突可能时间复杂度也会到达O(N),当然只是我的猜测而已，大神的想法又不是我这种蒟蒻能揣测的)</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>双向链表，用于存放就绪事件。（为什么是双向链表？</p><h3 id="主要的数据结构"><a href="#主要的数据结构" class="headerlink" title="主要的数据结构"></a>主要的数据结构</h3><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">spin_lock_t</span> lock;            <span class="hljs-comment">//对本数据结构的访问</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mtx</span>;</span>            <span class="hljs-comment">//防止使用时被删除</span>    <span class="hljs-keyword">wait_queue_head_t</span> wq;        <span class="hljs-comment">//sys_epoll_wait() 使用的等待队列</span>    <span class="hljs-keyword">wait_queue_head_t</span> poll_wait; <span class="hljs-comment">//file-&gt;poll()使用的等待队列</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllist</span>;</span>    <span class="hljs-comment">//事件满足条件的链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">rbr</span>;</span>          <span class="hljs-comment">//用于管理所有fd的红黑树</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">ovflist</span>;</span>      <span class="hljs-comment">//将事件到达的fd进行链接起来发送至用户空间</span>&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">rbn</span>;</span>            <span class="hljs-comment">//用于主结构管理的红黑树</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllink</span>;</span>       <span class="hljs-comment">//事件就绪队列</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">next</span>;</span>           <span class="hljs-comment">//用于主结构体中的链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_filefd</span> <span class="hljs-title">ffd</span>;</span>         <span class="hljs-comment">//每个fd生成的一个结构</span>    <span class="hljs-keyword">int</span> nwait;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pwqlist</span>;</span>     <span class="hljs-comment">//poll等待队列</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span>          <span class="hljs-comment">//该项属于哪个主结构体</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">fllink</span>;</span>         <span class="hljs-comment">//链接fd对应的file链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>;</span>  <span class="hljs-comment">//注册的感兴趣的事件,也就是用户空间的epoll_event</span>&#125;</code></pre><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>调用<code>epoll_create()</code>在内核中创建一个事件表，然后调用<code>epoll_ctl()</code>添加文件描述符，最后用<code>epoll_wait()</code>等待就绪事件发生。</p><p>利用红黑树，可以防止同一个文件描述符<code>fd</code>重复添加到事件列表中。当添加了用户关心事件的文件描述符被加入到红黑树中时，都会有一个回调函数<code>ep_poll_callback</code>与这个文件描述符绑定。这个回调函数也就是上面提出问题的那个回调函数。</p><p>当事件发生之后，就会触发这个回调函数，将该就绪事件添加到<strong>双向链表</strong>当中去。到这里，之前的问题就可以解答了： 这个回调函数只是将文件描述符添加到链表当中去，而不是用于返回<code>epoll_wait</code>。</p><p>在调用epoll_wait时，只需要<strong>去重</strong>，然后返回。去重的原因，可能有事件重复触发了几次，我们只需要一次就够了。（双向链表，红黑树，是否可以提出一个问题 – 在内核空间中，连续的空间是否比较少。</p><p><img src="https://img2018.cnblogs.com/blog/1300168/201811/1300168-20181121194549799-1443021669.jpg" alt="img"></p><h2 id="电平触发（LT-边沿触发（ET）"><a href="#电平触发（LT-边沿触发（ET）" class="headerlink" title="电平触发（LT)   边沿触发（ET）"></a>电平触发（LT)   边沿触发（ET）</h2><p>epoll对文件描述符的操作有两种模式，电平触发（LT）和边沿触发（ET）。默认情况下是电平触发。这两个模式是放在<code>epoll_event.events</code>中，用<code>|</code>进行设置。</p><h3 id="LT"><a href="#LT" class="headerlink" title="LT"></a>LT</h3><p>对于采用LT工作模式的文件描述符，当<code>epoll_wait</code>检测到其上事件发生并将其通知到应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用<code>epoll_wait</code>时，<code>epoll_wait</code>还会再次向应用程序通告此事件，直到该数据被处理。</p><p>这是《Linux高性能服务器编程》的原话。为什么应用程序可以不立即处理这个事件？应用程序不是程序员自己写的么？事件来了为什么不进行操作？需要加什么标志位么？</p><p>知乎大佬的<a href="https://zhuanlan.zhihu.com/p/73231499">解释</a></p><blockquote><p>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p></blockquote><p>在LT模式下进行（需要设置偏移量？</p><p>​            读： 如果需要读的内存缓冲区一次没有读完，即内核缓冲区还有数据可读，读事件就一直触发</p><p>​            写： 发送缓冲区不满，可以继续写入数据，写事件一直触发</p><p>LT的读写取决于buff</p><p>在LT模式下，事件可以多次添加到<code>rdlist</code>链表当中，会被多次触发，可能会影响效率。</p><p><del>假设在多线程的情况下，可能会出现多个线程对一个文件描述符操作，那么会产生竞态环境。如果有线程对文件描述符进行操作，那么在LT模式下就会一直处于就绪态。</del>（这是我在看ET模式 <code>EPOLLONESHOT</code>事件产生的联想，仅是个人理解。但是在后续看到<code>惊群效应</code>的时候，<code>epoll</code>之所以没有像<code>accpet</code>一样采取措施防止惊群，是考虑到用户可能要在多个线程中对同一个文件描述符进行操作（应该是读操作吧，写操作会产生竞态环境）,那么按照我的思想来说，就不允许多个线程对同一个文件描述符进行操作，所以可能是错误的）</p><h3 id="ET"><a href="#ET" class="headerlink" title="ET"></a>ET</h3><p>在ET模式下，当<code>epoll-wait</code>检测到其上事件发生并将其上有事件发生并将此事件通知应用程序后，应用程序<strong>必须立即处理</strong>该事件，因为后续将不再通知这一事件（但是凡事都有例外）</p><p>​            读：当有就绪的读事件发生，只要buff中有数据，就应该读完</p><p>​            写： 只有buff中有数据没有写满，就一直写</p><p>ET模式下是看状态的转化</p><p>在ET模式下，每个文件描述符都应该是<strong>非阻塞</strong>的。如果文件描述符是阻塞的，那么由于读或者写操作而一直处于阻塞状态。而LT模式不会出现这种状况：第一次读取或者写一定可以成功，如果读或写完毕，就直接退出了。</p><p>由于<code>socket</code>是文件描述符，所以服务器在读取的时候客户端会一直发送消息，这样即使是在ET模式下也会以为数据过大而多次触发。</p><h4 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h4><p>我们期望一个socket上在任一时刻都只被一个线程处理。这时候我们可以在事件中注册<code>EPOLLONESHOT</code></p><p>对于注册了<code>EPOLLONESHOT</code>事件的文佳描述符，操作系统最多触发其上注册的一个可读可写或者异常事件（固定了线程PID？）这样其他线程就无法对其进行修改。</p><p>注册了<code>EPOLLONESHOT</code>事件的<code>socket</code>一旦被某个线程处理完毕，该线程就应该立即重置这个<code>socket</code>上的<code>EPOLLONESHOT</code>事件，以确保下一次可读，其他工作线程可以处理这个<code>socket</code></p><h3 id="LT模式和ET模式例子"><a href="#LT模式和ET模式例子" class="headerlink" title="LT模式和ET模式例子"></a>LT模式和ET模式例子</h3><p>书上的源码，稍微修改了一下。虽然是能编译过的，但是不保证逻辑的正确性，可以参考。（后续有时间可以改一下，贴一堆垃圾上来确实不好，但是最近有些忙碌，英语听力把人听傻了）</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt; //用于存放基本数据类型，一般系统编程都最好加上，有pid_t这种进程编号ID</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;     //socket套接字函数</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;       //定义数据结构socketaddr_in，这个数据结构用于存放ip地址</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;      //提供ip地址转换的函数</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;     //断言</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;  //标准输入输出</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;  //系统编程函数</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;  //报错，在本例中需要用到GAGAIN等，非阻塞时如果缓冲区没有东西出现的错误</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;     //string函数,可以用memset取代bzero初始化</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;  //可以修改文件描述符,把文件描述符转化成非阻塞这个段代码需要背出来</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;  //IO复用</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;    //多线程函数库，创建一个内核级线程</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENT_NUMBER 1024   <span class="hljs-comment">//最大事件的大小</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 10  <span class="hljs-comment">//缓冲区大小</span></span><span class="hljs-comment">//修改fd的状态，返回旧状态。fcntl这种函数完美符合2/8定律</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-keyword">int</span> fd )</span></span>&#123;    <span class="hljs-keyword">int</span> old_option = fcntl( fd, F_GETFL );    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;    fcntl( fd, F_SETFL, new_option);    <span class="hljs-keyword">return</span> old_option;&#125;<span class="hljs-comment">//调用epoll_ctl函数，这里只是加入，并且只加入了读事件，也就是EPOLLIN，通过bool来确定是那个模式（LT/ET),默认是LT</span><span class="hljs-comment">//我可以再添加写事件</span><span class="hljs-comment">//可以处理带外数据</span><span class="hljs-comment">//处理错误</span><span class="hljs-comment">//一般来说（看教材的），EPOLLIN，EPOLLOUT，EOLLERR用的比较多</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">bool</span> enable_et)</span></span>&#123;    epoll_event ev;    ev.data.fd = fd;    <span class="hljs-comment">//这里是有读事件，但是没有写事件，其实可以加上，但是后天就要考试啦！！！</span>    ev.events = EPOLLIN;    <span class="hljs-keyword">if</span>( enable_et )&#123;        ev.events |= EPOLLET;    &#125;     setnonblocking(fd);    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">newConnet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> listenfd,<span class="hljs-keyword">bool</span> flag)</span></span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span>    <span class="hljs-keyword">socklen_t</span> client_addresslength = <span class="hljs-keyword">sizeof</span> (client_address);    <span class="hljs-keyword">int</span> connfd = accept( listenfd,(struct sockaddr*)&amp;client_address,&amp;client_addresslength);    addfd( epollfd,connfd,flag);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lt</span><span class="hljs-params">(epoll_event* events, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> listenfd)</span></span>&#123;    <span class="hljs-keyword">char</span> buf[BUFFER_SIZE];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; number; i++)&#123;        <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;        <span class="hljs-keyword">if</span>(sockfd == listenfd)&#123;            newConnet(epollfd,listenfd,<span class="hljs-literal">false</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event trigger once\n&quot;</span>);            <span class="hljs-built_in">memset</span>(buf ,<span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);            <span class="hljs-keyword">int</span> ret = recv(sockfd,buf,BUFFER_SIZE<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span> )&#123;                close(sockfd);                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of connent: %s\n&quot;</span>,ret,buf);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLOUT)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;events trigger once\n&quot;</span>);            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* buf=<span class="hljs-string">&quot;chaij&#x27;s blog&quot;</span>;            <span class="hljs-keyword">int</span> ret = send(sockfd,buf,BUFFER_SIZE,<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)&#123;                close(sockfd);                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send %d bytes of connet\n&quot;</span>,ret);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timeout\n&quot;</span>);        &#125;    &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">et</span><span class="hljs-params">(epoll_event* events, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> listenfd)</span></span>&#123;    <span class="hljs-comment">//在ET模式下，文件描述符一定是非阻塞的，原因详见笔记</span>    <span class="hljs-keyword">char</span> buf[ BUFFER_SIZE ];    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)&#123;        <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;        <span class="hljs-keyword">if</span>(sockfd == listenfd)&#123;            newConnet(epollfd,listenfd,<span class="hljs-literal">true</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( events[i].events &amp; EPOLLIN)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;events trigger read once\n&quot;</span>);            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;                <span class="hljs-built_in">memset</span>(buf,<span class="hljs-string">&#x27;\0&#x27;</span>,BUFFER_SIZE);                <span class="hljs-keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);                <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span>)&#123;                    <span class="hljs-comment">//对于ET模式，也就是边缘触发，要求数据一次性读完。其实这样说是不正确的，当数据很大的时候，边缘读取其实到边缘也无法全部读取完毕</span>                    <span class="hljs-comment">//当无法读取的时候，会报错，EAGIN，意味再来一次，也就是说缓冲区已经被读取完毕</span>                    <span class="hljs-keyword">if</span>( (errno == EAGAIN ) || ( errno == EWOULDBLOCK) )&#123;                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read later\n&quot;</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                    close(sockfd);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)&#123;                    close( sockfd );                &#125;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf );                &#125;            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( events[i].events &amp; EPOLLOUT)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;events trigget write once\n&quot;</span>);            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* buf=<span class="hljs-string">&quot;chaij&#x27;s blog&quot;</span>;            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;                <span class="hljs-comment">//memset(buf,&#x27;\0&#x27;,BUFFER_SIZE);</span>                <span class="hljs-keyword">int</span> ret = send(sockfd, buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);                <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span>)&#123;                    <span class="hljs-comment">//对于ET模式，也就是边缘触发，要求数据一次性读完。其实这样说是不正确的，当数据很大的时候，边缘读取其实到边缘也无法全部读取完毕</span>                    <span class="hljs-comment">//当无法读取的时候，会报错，EAGIN，意味再来一次，也就是说缓冲区已经被读取完毕</span>                    <span class="hljs-keyword">if</span>( (errno == EAGAIN ) || ( errno == EWOULDBLOCK) )&#123;                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write later\n&quot;</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                    close(sockfd);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)&#123;                    close( sockfd );                &#125;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;write %d\n&quot;</span>,ret);                &#125;            &#125;        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happened \n&quot;</span>);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span>* argv[])</span></span>&#123;        <span class="hljs-keyword">if</span>(argc &lt;= <span class="hljs-number">2</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ip/port is empty\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//下面是最常用的socket编程过程</span>    <span class="hljs-comment">//listen 发生在第二次握手当中</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> port = atoi(argv[<span class="hljs-number">2</span>]);        <span class="hljs-keyword">int</span> ret=<span class="hljs-number">0</span>;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span>    <span class="hljs-built_in">memset</span>(&amp;address,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> address);    address.sin_port = htons(port);    address.sin_family = AF_INET;    inet_pton(AF_INET,ip,&amp;address.sin_addr);    <span class="hljs-keyword">int</span> listenfd = socket( PF_INET, SOCK_STREAM,<span class="hljs-number">0</span>);    assert(ret != <span class="hljs-number">-1</span>);    <span class="hljs-comment">//因为需要通用的地址，所以需要转换成统一的。虽然size不一样，但是可以利用变长数组</span>    ret = bind( listenfd, (struct sockaddr* )&amp;address, <span class="hljs-keyword">sizeof</span> address);    assert(ret != <span class="hljs-number">-1</span>);    <span class="hljs-comment">//绑定之后需要accpet读取数据,</span>    <span class="hljs-comment">//为什么有了acppet还需要使用epoll？accpet只能对应一个套接字，用完了就废弃了。最关键的是accpet出来的套接字没有</span>    <span class="hljs-comment">//事件性质。</span>    ret = listen( listenfd, <span class="hljs-number">5</span>);    assert(ret != <span class="hljs-number">-1</span>);    epoll_event events [MAX_EVENT_NUMBER];    <span class="hljs-keyword">int</span> epollfd = epoll_create(<span class="hljs-number">5</span>);    assert(ret != <span class="hljs-number">-1</span>);    addfd(epollfd,listenfd,<span class="hljs-literal">true</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        <span class="hljs-keyword">int</span> ret = epoll_wait( epollfd, events, MAX_HANDLE_SZ, <span class="hljs-number">-1</span>); <span class="hljs-comment">//这里的-1设置成了阻塞，如果没有就绪事件将会一直阻塞</span>        <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure]\n&quot;</span>);            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">//水平触发</span>        lt(events,ret,epollfd,listenfd);        <span class="hljs-comment">//边缘触发</span>        <span class="hljs-comment">//et(events,ret,epollfd,listenfd);</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="accpet-问题"><a href="#accpet-问题" class="headerlink" title="accpet 问题"></a>accpet 问题</h3><h4 id="如果accpet的监听文件描述符阻塞"><a href="#如果accpet的监听文件描述符阻塞" class="headerlink" title="如果accpet的监听文件描述符阻塞"></a>如果accpet的监听文件描述符阻塞</h4><p>这里需要提到的是<code>accpet</code>的问题，见Linux高性能服务器开发p80页所提到的，<code>accpet</code>只是从监听队列中取出连接，而无论连接处于何种状态。在上面列举的代码中，可以清楚的看见虽然连接已经断开，但是TCP队列里面依然有这个套接字</p><p>需要注意的是，<code>RST复位键</code>却可以将已经完成的连接<strong>驱逐</strong>出TCP连接(UNP16.6章)，这样会出现一个定时问题。如果客户端先发送一个读写事件，然后监听事件就绪，acppet可以调用一个已经完成的连接，返回一个套接字。但是在此时，如果客户端发送了一个RST，就会导致accpet里面的连接被删除，这样由于监听事件还是过了if语句的，但是accpet里面却没有可以用的连接，这样会导致accpet阻塞，之后的操作将无法继续，直到有新的连接。所以需要吧<strong>监听事件设置为非阻塞</strong>。</p><h4 id="监听描述符ET模式下accpet存在的问题"><a href="#监听描述符ET模式下accpet存在的问题" class="headerlink" title="监听描述符ET模式下accpet存在的问题"></a>监听描述符ET模式下accpet存在的问题</h4><p><code>accpet</code>还有一个问题，如果同时有多个连接到达，但是监听事件只触发一次，<code>accpet</code>也只触发一次，那么就会导致之后的连接无法被加入到<code>epoll</code>之中去,虽然<code>accpet</code>仍然有连接，但是只能通过之后的连接来触发监听事件的就绪，才能继续调用<code>accpet</code>，造成效率上的问题，也可能导致连接无法继续，所以要用<code>while</code>将连接的事件全部返回。</p><p>这是只有ET模式下才会出现的问题，如果是LT模式下<code>acppet</code>还有事件可读，就会成为就绪事件被继续读取（所以改为LT模式应该也可以）</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>限于篇幅（嗯，我懒），主要<a href="https://www.cnblogs.com/l2017/p/10830391.html">参考</a>这个大佬的，将的很详细（很多都看不明白），<del>我后续如果有时间可以细看</del></p><p>源码不会骗人</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/U0%5BSGUOMKP%5BSNRA00V_A@AS.png" alt="img"></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://blog.chinaunix.net/uid-28541347-id-4273856.html">http://blog.chinaunix.net/uid-28541347-id-4273856.html</a></p><p><a href="https://www.cnblogs.com/tianzeng/p/9997432.html">https://www.cnblogs.com/tianzeng/p/9997432.html</a></p><p><a href="https://www.cnblogs.com/l2017/p/10830391.html">https://www.cnblogs.com/l2017/p/10830391.html</a></p><p><a href="https://www.zhihu.com/question/39792257">https://www.zhihu.com/question/39792257</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步/异步，阻塞/非阻塞</title>
    <link href="/WennyAhhh.github.io/2020/12/08/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%20%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <url>/WennyAhhh.github.io/2020/12/08/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%20%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="同步-异步，阻塞-非阻塞"><a href="#同步-异步，阻塞-非阻塞" class="headerlink" title="同步/异步，阻塞/非阻塞"></a>同步/异步，阻塞/非阻塞</h1><blockquote><p>最近在学习Linux网络编程的时候遇到了IO模型，对于同步IO，异步IO，同步，异步，阻塞，非阻塞等这些术语，感到其定义十分模糊。尤其是抛出–epoll是同步还是异步？阻塞还是非阻塞?这个问题后，我翻阅了网上很多博主的博文，答案有些不一样，愈发感到晦涩难懂。在困扰了一个晚上外加一个上午后，才发现我已经走向死胡同了，每个答主所说的层次并不一样。</p><p>对于这些概念来说，除了应付面试，一无是处（逃，好像我不是一无是处一样</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前就已经听闻了这几个名词的大名，去知乎上逛了一圈，满心欢喜地以为自己会了。知道最近在学习IO复用，再回头审视这些概念，才明白其中的内容并没有那么简单。</p><p>参考知乎两位大佬的两篇文章<a href="https://www.zhihu.com/question/19732473/answer/117012135">（一）</a><a href="https://www.zhihu.com/question/19732473/answer/88599695">（二）</a>。我们应该站在<strong>不同的层面</strong>上看待这些问题。可以粗略分为<strong>应用级别同步/异步</strong>,<strong>操作系统同步/异步</strong>。应用级别的同步异步是基于操作系统的，比如Nginx是异步非阻塞，但是是基于epoll（操作系统层次）的同步非阻塞（非阻塞不一定，后续再说）。</p><p>需要注意一点。在异步编程中，会提起同步/异步，这一般就是上述中一般的同步/异步，但是这与<strong>IO模型</strong>中的同步异步是<strong>完全不同</strong>的概念。由于站在不同的层面上，可以提到的东西就太多了，同步IO，异步IO，同步，异步，回调，阻塞，非阻塞，并行，并发，多线程，牵扯到了进程，线程，协程，其中线程还包括三种概念：内核线程，轻量级进程（LWP），用户线程，再往深处，Linux对于进程/线程的处理。（我一开始写的时候没有打算写那么多，然后写的时候发现与这些概念都混淆了，虽然有些东西很早之前就理解了，但是出现一个新知识的时候，才发现需要理解的不够。）</p><p>本文只涉及IO模型和进程间通信的相关内容。</p><p>本人没有野心把这种繁杂的概念一一理清，毕竟这些概念除了和面试官聊（chui）得（niu）开（pi）以外，对于代码提升没有什么帮助。</p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>在学习计算机组成原理的时候，提到过DMA的工作方式 </p><p>​                         <img src="https://i.loli.net/2020/12/07/E4WKLQxe81qnVOD.png"></p><p>由于主存和DMA接口之间有一条数据通路，因此主存和设备交换信息时，不通过CPU，也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复线程，因此工作速度比程序中断的工作速度高。具体的内容可以参考《计算机组成原理》，有更加详细的解释。</p><p>在这里需要指出的是，DMA对于CPU来说，只有传输开始和结束的时候需要发出中断指令，其他的时间都不需要CPU参与。所以是异步非阻塞。异步体现在IO的回调，是CPU被动的，非阻塞体现在CPU依然在运行其他程序。</p><h2 id="应用级别"><a href="#应用级别" class="headerlink" title="应用级别"></a>应用级别</h2><blockquote><p>对于同步异步来说，是对应<strong>两个或多个关系</strong>的。</p><ul><li><p>同步操作时，调用者需要等待被调用者返回结果，才会进行下一步操作</p></li><li><p>异步则相反，调用者不需要等待被调用者返回调用，即可进行下一步操作，被调用者通常依靠事件、回调等机制来通知调用者结果。</p></li></ul><p>对于阻塞和非阻塞来说，是<strong>当前进程的状态</strong>。</p><ul><li><p>阻塞就是当前进程被挂起，暂时放弃CPU，直到调用线程调用完毕，并返回结果和状态。</p></li><li><p>非阻塞是不能立刻得到结果之前，该调用者不会阻塞当前进程。而是直接返回状态。</p></li></ul></blockquote><p>通俗一点来说，可以参考知乎上的“<a href="https://www.zhihu.com/question/19732473/answer/23434554">水壶模型</a>”(嗯，我懒得写了)。</p><p>需要注意的是，这两个概念并非完全是是毫不相干的，因为异步会执行下一个任务，那么就必不可能阻塞。同理，同步也不会非阻塞而放弃等待返回值。关于异步处理的流程需要参照各种框架。比方说python的协程（同步阻塞），nginx（异步非阻塞）。</p><p>但是有些框架，比如Node.js都是异步的，如果需要同步，那么就需要异步阻塞。</p><p>对于轮询操作，是同步非阻塞的。</p><p>当然，也有大佬提出：进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词。</p><p>同步异步模型也可以放入操作系统级别之中，虽然我认为这个套用毫无意义。</p><h2 id="线程层次"><a href="#线程层次" class="headerlink" title="线程层次"></a>线程层次</h2><p>Stevens大神在UNP中提到了<strong>五种IO模型</strong>。(IO应该要打成I/O)</p><ul><li><strong>阻塞式IO</strong></li><li><strong>非阻塞式IO</strong></li><li><strong>IO复用</strong>（select，poll, epoll,其中epoll是后面出来的，没有写入UNP中。）</li><li><strong>信号驱动式IO</strong>(SIGIO)</li><li><strong>异步IO</strong></li></ul><p>其中前面四种都是<strong>同步IO</strong>,最后一种才是<strong>异步IO</strong>。暂且抛开同步异步，阻塞非阻塞的隔阂，什么是<strong>IO操作</strong>?一个输入操作通常包括两个不同阶段</p><ol><li><p>等待数据准备好，就绪</p></li><li><p>从内核缓冲区向进程复制数据</p></li></ol><p>严格来说，如果发起recv请求，第一步并没有准备好，那么这个等待的过程就是阻塞，线程挂起，因为这个时间段是不需要消耗CPU的。</p><p>但是，如果当前是二阶段，且是同步IO，那么用recv从内核缓存读取线程就不能算作阻塞。如果对这些理解不是很明白，可以先略过，回头再看。</p><p>在理解这些概念的时候不要将应用级别的同步异步带入到这里，因为是不同级别的概念，也不要试图去找共同点，找到的只是你认为的共同点而已，没有意义。</p><h3 id="阻塞式IO模型"><a href="#阻塞式IO模型" class="headerlink" title="阻塞式IO模型"></a>阻塞式IO模型</h3><p>最流行的IO模型就是阻塞式IO模型。在默认情况下，所有的套接字都是阻塞的。</p><p>当我们调用recv读取数据，如果数据没有，那么从无数据准备好到有数据准备好（第一步），是个阻塞的过程。</p><p>数据存在了之后，由recv复制到用户空间。</p><p><img src="https://static.oschina.net/uploads/img/201604/20150405_VKYH.png" alt="输入图片说明"></p><p>数据只能在recv读入完成之后才返回。</p><p>第一阶段同步阻塞</p><h3 id="非阻塞式IO模型"><a href="#非阻塞式IO模型" class="headerlink" title="非阻塞式IO模型"></a>非阻塞式IO模型</h3><p>进程把一个套接字设置成非阻塞，在recv的时候，如果需要等待第一步，非阻塞就直接返回一个错误。可以循环发起recv请求，如下图。直到第四次调用有数据了，才会被复制到进程缓冲区。</p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/20152818_DXcj.png"/><p>当对一个<strong>非阻塞描述符</strong>循环调用recv时，称之为<strong>轮询</strong>。</p><p>第一阶段同步非阻塞</p><p>在看到很多博文，在关于select中说到这个轮询。这其实是错误的，虽然这个名字很好听。应该叫做遍历更为恰当（当然是我自己的想法）</p><h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>IO复用有select，poll和epoll，会着重讲解用的比较多的epoll 。</p><p>利用IO复用，就可以阻塞在IO复用之上，而不是阻塞在真正的IO系统调用之上（不讲人话</p><p>其实就是在第一阶段和第二阶段分开，让文件描述符阻塞在IO复用上，其中IO复用可能有多个文件描述符。我们阻塞IO复用，等待数据报套接字变为可读，然后返回套接字可读（也就是第一阶段完成，成为就绪事件）， 就调用recv进行第二阶段。</p><p>​                          <img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/DQ@HGRK%5BWZ%5D5%60L%7DWW%7BM@6DW.png"></p><p>这里很简单地介绍一下几个IO复用，以后有机会补上（咕咕咕</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>​    在第一阶段完成后 select中包含了就绪事件，但是并不保证所有的事件都是就绪事件，所有需要遍历，时间复杂度为O（N）。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>​    虽然比select能有更多的事件处理类型，但是依然存在O(N)的问题。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>​    由于都是调用函数返回的，第一阶段是同步的，至于是不是非阻塞，如果timeout=0那么是非阻塞，如果timeout&gt;0那么会阻塞一段时间，-1为一直阻塞</p><h3 id="信号驱动式IO模型"><a href="#信号驱动式IO模型" class="headerlink" title="信号驱动式IO模型"></a>信号驱动式IO模型</h3><p>这个模型用的少，其实还是很值得讨论的。可惜没人待见，少了热度，像极了人生</p><p>利用信号，让内核在描述符就绪时发送SIGIO信号通知。如下图，通过建立SIGIO信号处理程序，建立完立刻返回，进程继续工作，也不需要进行轮询。等到第一阶段完成，发送一个SIGIO信号给信号处理程序，然后调用recv读出数据。</p><p>​                          <img src="https://pic4.zhimg.com/80/6294fb7f7f5c22e39187a490c35ac6f0_720w.jpg?source=1940ef5c" alt="img"></p><p>最大的好处是在于等待数据包达到期间进程不被阻塞，主循环可以继续执行，只要等待信号处理函数的通知就可以了。</p><p>由于返回的通知是回调，并且进程未阻塞，所以应该是第一阶段是异步非阻塞模型。</p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>和信号驱动IO很像，但是区别在于信号驱动IO只能用信号通知用户已经准备完成，然后启动第二阶段，但是异步IO是将第二阶段也交给了内核处理，返回一个信号。</p><p>​                    <img src="https://static.oschina.net/uploads/img/201604/20175459_gtgw.png" alt="输入图片说明"></p><p>Linux有AIO库，调用aio_read()函数，给内核传递描述符，缓冲区（需要告诉用户缓冲区的位置），缓冲大小，文件偏移（如果有多个线程同时写？）,并设置一个回调函数。用户进程在调用AIO时直接返回，进程不阻塞。</p><p>由此来看同步IO在第二个阶段由于都是函数返回，且有数据，所以是同步非阻塞模型</p><p>对于异步IO来说，两个阶段是一起的，异步非阻塞模型。</p><h3 id="同步IO与异步IO"><a href="#同步IO与异步IO" class="headerlink" title="同步IO与异步IO"></a>同步IO与异步IO</h3><p>POSIX把这两个术语定义如下：</p><ul><li><strong>同步IO操作</strong> 导致请求进程阻塞，直到IO操作完成</li><li><strong>异步IO操作</strong> 不导致请求进程阻塞</li></ul><p>什么是请求进程？recv就是。对于一个文件描述符设置为非阻塞，只有在没有数据就绪的时候，会直接返回。如果有数据，那么文件描述符阻塞不阻塞都无所谓，都需要从内核缓冲区写入到用户缓冲区，此时，上述四种都是阻塞的，直到IO操作。所以前四种都是同步IO。</p><p>只有异步IO，在其中调用了AIO，在内核中写入数据，请求进程直接返回，才符合异步IO的定义。</p><p>在IO时间中，同步和异步区分的是内核向应用程序通知的是何种IO事件（是就绪时间还是完成事件），以及该由谁来完成IO读写（是应用程序还是内核）</p><p>一言蔽之，第二个阶段是谁完成的。如果是内核完成的，那么就是异步IO，如果是用户完成的，那么就是同步IO。</p>]]></content>
    
    
    <categories>
      
      <category>Linux网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 493.翻转对</title>
    <link href="/WennyAhhh.github.io/2020/11/29/LeetCode%20493.%E7%BF%BB%E8%BD%AC%E5%AF%B9/"/>
    <url>/WennyAhhh.github.io/2020/11/29/LeetCode%20493.%E7%BF%BB%E8%BD%AC%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-493-翻转对"><a href="#LeetCode-493-翻转对" class="headerlink" title="LeetCode 493.翻转对"></a>LeetCode 493.翻转对</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>原题<a href="https://leetcode-cn.com/problems/reverse-pairs/">链接</a></p><blockquote><blockquote><p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p></blockquote><p>你需要返回给定数组中的重要翻转对的数量。</p><p>示例 1:</p><p>输入: [1,3,2,3,1]<br>输出: 2</p><p>示例 2:</p><p>输入: [2,4,3,5,1]<br>输出: 3</p><p>注意:</p><p>​    给定数组的长度不会超过50000。<br>​    输入数组中的所有数字都在32位整数的表示范围内。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>输入: [1,3,2,3,1]<br>输出: 2</p></blockquote><table><thead><tr><th>res1: 1 3 2 3 1 （依据题意每个*2</th></tr></thead><tbody><tr><td>res2: 2 6 4 6 2</td></tr></tbody></table><p>这道题目就变成了，给定一个位置pos，res2[pos-n] 比 res1[pos]大的值的数量</p><p>那么朴素的思路就是，建一个哈希表，然后从后往前遍历，对于每个res1[i],只需要遍历哈希表，找出比res1[i]小的个数，记录下来，然后在哈希表中存入res2[i]。</p><p>首先，数的大小范围是32位整数，包括负数，导致自己创造哈希表需要加上一个偏移量，还有数组过大的问题。×2还会导致整数溢出。</p><p>每次都要遍历一次哈希表，时间复杂度过高。如果使用前缀和，会导致插入操作的时间复杂度为O(n);</p><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>可以使用一个<code>unordered_map</code>进行离散化数据。由于需要比较的是两个数组的所有值，所以需要吧两个数组合在一起，排序，编号。</p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>线段树是用于求前缀和，插入的时间复杂度是O(logN),求前缀和的时间复杂是O(logN)。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> n=<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> fa[<span class="hljs-number">100010</span>];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;        <span class="hljs-keyword">return</span> x&amp;-x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)&#123;            res+=fa[x];            x-=lowbit(x);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> k)</span></span>&#123;        <span class="hljs-keyword">while</span>(x&lt;=n)&#123;            fa[x]+=k;            x+=lowbit(x);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-comment">//前缀和和树状数组</span>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; tem;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; e:nums)&#123;            tem.push_back(e);            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k=e;            tem.push_back(k*<span class="hljs-number">2</span>);        &#125;        sort(tem.begin(),tem.end());        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>,<span class="hljs-keyword">int</span>&gt; res;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; e:tem)&#123;            res[e]=n++;        &#125;        <span class="hljs-keyword">int</span> m=nums.size();        <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)nums[i]*<span class="hljs-number">2</span>;            cur+=ask(res[nums[i]]<span class="hljs-number">-1</span>);            updata(res[k],<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> cur;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条款38 has-a 条款39 明智而审慎地使用private继承</title>
    <link href="/WennyAhhh.github.io/2020/11/07/%E6%9D%A1%E6%AC%BE38%20has-a%20%E6%9D%A1%E6%AC%BE39%20%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF/"/>
    <url>/WennyAhhh.github.io/2020/11/07/%E6%9D%A1%E6%AC%BE38%20has-a%20%E6%9D%A1%E6%AC%BE39%20%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="条款38-has-a-条款39-明智而审慎地使用private继承"><a href="#条款38-has-a-条款39-明智而审慎地使用private继承" class="headerlink" title="条款38 has-a 条款39 明智而审慎地使用private继承"></a>条款38 has-a 条款39 明智而审慎地使用private继承</h1><hr><p><code>public</code>继承都有 一种<code>is-a</code>的意义，在UML中还存在一种<code>has-a</code>的关系，对应的</p><h2 id="private继承"><a href="#private继承" class="headerlink" title="private继承"></a>private继承</h2><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span>..&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span> <span class="hljs-keyword">private</span> Person&#123;...&#125;;Person p;Student s;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Person&amp; p)</span></span>;eat(p); <span class="hljs-comment">//正确</span>eat(s); <span class="hljs-comment">//错误 </span></code></pre><p>不同于<code>public</code>继承，经过实测，编译器都不会自动将<code>private</code>继承和<code>protected</code>继承转化为<code>derived class</code>对象，并且，<code>base class</code>中的成员在<code>derived class</code>都将成为<code>private</code>成员，无论之前是<code>public</code>或者<code>protected</code>。</p><p>当我们需要一些工具放在我们的clas中时，并且这个工具类中有<code>virtual</code>函数，我们需要通过继承来重新定义这个工具类。<code>is-a</code>意义的<code>public</code>继承不是一个好选择，所以我们采用<code>private</code>继承</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tickFrequency)</span></span>&#123;&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span><span class="hljs-keyword">private</span> Timer&#123;<span class="hljs-keyword">private</span>:    <span class="hljs-comment">//private防止客户误用接口</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;&#125;</code></pre><h2 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h2><p><code>private</code>继承在有些场合是没有必要的，完全可以使用复合对象（条款38）来完成</p><pre><code class="hljs cpp"><span class="hljs-comment">//WidgetTimer.h</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidigetTimer</span>:</span><span class="hljs-keyword">public</span> Timer&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;&#125;<span class="hljs-comment">//WidgetTimer.cpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Timer&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WidgetTimer::onTick</span><span class="hljs-params">()</span></span>&#123;    ...&#125;<span class="hljs-comment">//Widget.h</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetTimer</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>&#123;</span><span class="hljs-keyword">private</span>:    WidgetTimer timer;&#125;</code></pre><p>上例采用了复合，WidgetTimer is a Timer 并没有什么问题，并且为尽量减少编译依存度，不采用内部类，而是分离出来。<br>有一种激进的情况，空间最优化。如上例，在内部创建一个类总是需要空间的，而我需要使用的工具类中不带有任何数据，<code>non-static</code>成员变量,<code>virtual</code>函数,<code>virtual base classes</code>，总之，实例化后占用空间为0的类，可以使用private继承空间最优化。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条款37 绝不重新定义继承而来的缺省参数</title>
    <link href="/WennyAhhh.github.io/2020/11/05/%E6%9D%A1%E6%AC%BE37%20%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0/"/>
    <url>/WennyAhhh.github.io/2020/11/05/%E6%9D%A1%E6%AC%BE37%20%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="条款37-绝不重新定义继承而来的缺省参数"><a href="#条款37-绝不重新定义继承而来的缺省参数" class="headerlink" title="条款37 绝不重新定义继承而来的缺省参数"></a>条款37 绝不重新定义继承而来的缺省参数</h1><h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>//学C++总感觉有些东西刚开始只能意会，反复琢磨才能区分。</p><p>参考<a href="https://www.cnblogs.com/lizhenghn/p/3657717.html">blog</a></p><p><strong>静态类型</strong>：对象在声明时采用的类型，在<strong>编译期</strong>既已确定；</p><p><code>int a=2;</code></p><p><strong>动态类型</strong>：通常是指一个指针或引用目前所指对象的类型，是在<strong>运行期</strong>决定的；</p><p><code>Shape* pc=new Circle  //ps的静态类型为Shape* 但是他的动态类型是Circle*,在运行期间给的</code></p><p><strong>静态绑定</strong>：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在<strong>编译期</strong>；</p><p><code>int a=2;  //对缺省参数值是动态绑定</code></p><p><strong>动态绑定</strong>：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在<strong>运行期</strong>；</p><p>``Shape* pc=new Circle //ps对Circle是动态绑定`</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>其实也是比较玄学下面看个例子（Effective C++抄的)</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">enum</span> ShapeColor &#123;Red,Green,Blue&#125;;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> :</span><span class="hljs-keyword">public</span> Shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Green)</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Rectangle: &quot;</span>&lt;&lt;color &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> :</span> <span class="hljs-keyword">public</span> Shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color)</span><span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Circle: &quot;</span>&lt;&lt;color &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;Shape* ps;<span class="hljs-comment">//ps只有静态类型</span>Shape* pr = <span class="hljs-keyword">new</span> Rectangle(); <span class="hljs-comment">//pr的静态类型为Shape* ，动态类型为Rectangle* 。是动态绑定，下同</span>Shape* pc = <span class="hljs-keyword">new</span> Circle();Rectangle* c = <span class="hljs-keyword">new</span> Rectangle();c-&gt;draw();pr-&gt;draw();pc-&gt;draw();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>​    运行结果</p><pre><code class="hljs cpp">Rectangle: <span class="hljs-number">1</span><span class="hljs-comment">//Green</span>Rectangle: <span class="hljs-number">0</span><span class="hljs-comment">//Red</span>Circle: <span class="hljs-number">0</span><span class="hljs-comment">//Red</span></code></pre><p>对于第一行结果，我们没有什么惊讶的。但是对于第二行，我们明明在<code>derived</code>中重新设置了缺省值，所以运行的应该也是<code>Green</code>，但是编译器和我们想的不一样。对于虚函数来说，是动态绑定的，<code>pr</code>绑定的是<code>derived</code>，所以在运行时调用的是<code>Rectangle</code>的<code>draw</code>。由于的<code>pr</code>的静态类型是<code>Shape*</code>，所以此调用的缺省值都是来自<code>Shape</code>的。</p><p>至于为什么<code>pr</code>不使用<code>Rectangle</code>静态绑定的缺省值,也就是<code>Green</code>。因为C++的性能压榨，对于<code>pr</code>来说，在编译期就已经确定好了静态类型<code>Shaped</code>，而其中的<code>draw</code>是动态类型，所以要在运行期才能绑定。那么为了效率，在编译期间就把缺省值固定住，机制更加简单,性能更好。</p><h2 id="NVI手法"><a href="#NVI手法" class="headerlink" title="NVI手法"></a>NVI手法</h2><p>综上所述，我们不应该在在<code>derived</code>中重新定义缺省值，但是在上述例子中</p><p><code>void draw(ShapeColor color) const;</code></p><p>当使用多态的时候，很好没有问题，他会继承base而来的缺省值，但是如果单独调用的话，也就是</p><p><code>Circle* pc=new Circle</code>注意，这里并没有继承base而来的缺省值，他<strong>什么都没有</strong>，需要用户指定。所以我们在使用有缺省值的<code>virtual</code>函数的时候，应该是这样的</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">enum</span> ShapeColor &#123;Red,Green,Blue&#125;;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-keyword">const</span></span>=<span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> :</span><span class="hljs-keyword">public</span> Shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Rectangle: &quot;</span>&lt;&lt;color &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;</code></pre><p>如果你面向对象的思维已经深入骨髓的话，你会嗤之以鼻：</p><p>1.代码重复，重复了<code>= Red</code><del>欲加之罪何患无辞</del></p><p>2.增加了<code>base</code>和<code>derived</code>的依存度，如果<code>base</code>需要修改的话，所有的<code>derived</code>也需要修改</p><p>其实这就是条款35，考虑<code>virtual</code>函数以外的其他选择，其中包含了 NVI（no-virtual interface），策略模式（函数指针和function）</p><p>对于客户端来说，策略模式需要知道其内部的实现，也就是 传递一个函数或者类。如果我都需要传递一个函数了，那么缺省值就直接设置，没有什么讨论的意义了，所以我们采用NVI的方法实现</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">enum</span> ShapeColor &#123;Red,Green,Blue&#125;;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color=Red)</span></span>&#123;        ...        dodraw();        ...    &#125;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-keyword">const</span></span>=<span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> :</span><span class="hljs-keyword">public</span> Shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Rectangle: &quot;</span>&lt;&lt;color &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;</code></pre><p>这样，把缺省值放在了<code>no-virtual</code>中，由于在第36条款中描述的，绝不重新定义继承而来的<code>no-virtual</code>函数，所以缺省值是不会被<code>derived class</code>覆写。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程学习(三).md</title>
    <link href="/WennyAhhh.github.io/2020/10/28/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%89/"/>
    <url>/WennyAhhh.github.io/2020/10/28/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C-多线程学习-三"><a href="#C-多线程学习-三" class="headerlink" title="C++多线程学习(三)"></a>C++多线程学习(三)</h1><p>等待时间或其他条件</p><p>（本来都打完了，然后切了后台，全没了（哭腔）</p><p>如果一个线程需要另外一个线程完成才能继续，例如队列，pop()的前提是empyt()为false，所以需要一个线程进行push操作，才能进行pop操作。</p><p>c++标准库提供了<code>std::condition_variable</code>和<code>std::condition_variable_any</code>，头文件在<code>&lt;condition_variable&gt;</code></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;condition_variable&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">threadsafe_queue</span> &#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-built_in">std</span>::mutex mut;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;T&gt; data_queue;    <span class="hljs-comment">//condition_variable只限于对mutex进行工作.condition_cariable_any可以是任意的，例如bool。常用前者</span><span class="hljs-built_in">std</span>::condition_variable data_cond;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span> </span>&#123;<span class="hljs-comment">//入队列，然后notify消息</span><span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;data_queue.push(new_value);        <span class="hljs-comment">//由于这里  notify是一对一的，因为push只有一个对象。他会在wait中只唤醒一个。</span>        <span class="hljs-comment">//如果是一对多的情况，就需要使用 notify_any()</span>data_cond.notify_one();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;        <span class="hljs-comment">//这里需要使用灵活的unique_lock，原因在于。如果wait返回的是false，那么就会解锁并进入阻塞状态</span>        <span class="hljs-comment">//如果另外一个线程调用了notify(),那么他会被唤醒，解除阻塞，并获取锁（加锁）。然后再次检测其函数，如果</span>        <span class="hljs-comment">//返回的是true,那么就继续下去，反之解锁，进入阻塞态，这样就造成了虚假唤醒</span>data_cond.wait(lk, [<span class="hljs-keyword">this</span>] &#123;<span class="hljs-keyword">return</span> !data_queue.empty();&#125;);value = data_queue.front();data_queue.pop();&#125;&#125;;threadsafe_queue&lt;<span class="hljs-keyword">int</span>&gt; data_queue;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">data_preatation_thread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;data_queue.push(i);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">data_processing_thread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">int</span> value=<span class="hljs-number">0</span>;data_queue.wait_and_pop(value);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">if</span> (i%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> x, y;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y;<span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">my1_thread</span><span class="hljs-params">(data_preatation_thread,x)</span></span>;<span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">my2_thread</span><span class="hljs-params">(data_processing_thread,y)</span></span>;        <span class="hljs-comment">//join别忘了！！</span>my1_thread.join();my2_thread.join();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-C++并发编程学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条款21 reference返回需要谨慎</title>
    <link href="/WennyAhhh.github.io/2020/10/19/%E6%9D%A1%E6%AC%BE21%20reference%E8%BF%94%E5%9B%9E%E9%9C%80%E8%A6%81%E8%B0%A8%E6%85%8E/"/>
    <url>/WennyAhhh.github.io/2020/10/19/%E6%9D%A1%E6%AC%BE21%20reference%E8%BF%94%E5%9B%9E%E9%9C%80%E8%A6%81%E8%B0%A8%E6%85%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="条款21-reference返回需要谨慎"><a href="#条款21-reference返回需要谨慎" class="headerlink" title="条款21 reference返回需要谨慎"></a>条款21 reference返回需要谨慎</h1><p>返回的对象如果是创建在栈中的，比如</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Ration&amp; lhs,<span class="hljs-keyword">const</span> Ration&amp; rhs)&#123;<span class="hljs-function">Ration <span class="hljs-title">result</span><span class="hljs-params">(...)</span></span>;<span class="hljs-comment">//构造函数，懒得写参数了。。。</span>.....<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">//客户端调用</span><span class="hljs-function">Ration <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<span class="hljs-function">Ration <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>;Ration res=a*b;<span class="hljs-comment">//是错误的</span></code></pre><p>以上代码会发生致命错误：在栈上实例化，在跳出作用域的时候调用析构函数，导致返回一个空引用。</p><p>如果在堆上创建，并且返回一个引用（当然不可能返回一个实例，如果返回一个实例的话就没地方delete）</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> Ration&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Ration&amp; lhs,<span class="hljs-keyword">const</span> Ration&amp; rhs)&#123;Ration *result=<span class="hljs-keyword">new</span> Ration(...);<span class="hljs-keyword">return</span> *result;&#125;</code></pre><p>这样会导致一个错误，内存泄漏。很容易会忘记delete，就算很小心翼翼，也会在不经意间出错</p><pre><code class="hljs cpp">Ration res=a*b*c;<span class="hljs-comment">//中间结果没有delete</span></code></pre><p>如果采用<code>static</code>,如果清楚全局变量，就会理解这种错误</p><pre><code class="hljs `cpp">const Ration&amp; operator*(const Ration&amp; lhs,const Ration&amp; rhs)&#123;static Ration result(....);...return result;&#125;&#x2F;&#x2F;这样由返回的是引用，所以&#x3D;&#x3D;前后返回的都是“现值”，也就是说 这个if语句只会返回true；if((a*b)&#x3D;&#x3D;(c*d))&#123;&#125;</code></pre><p>所以，不要盲目返回reference，还是使用by-value吧。在C++11中，有了move和forward，可以解决调用拷贝函数和析构函数的烦恼。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条款20，用引用取代传值</title>
    <link href="/WennyAhhh.github.io/2020/10/19/%E6%9D%A1%E6%AC%BE20%EF%BC%8C%E7%94%A8%E5%BC%95%E7%94%A8%E5%8F%96%E4%BB%A3%E4%BC%A0%E5%80%BC/"/>
    <url>/WennyAhhh.github.io/2020/10/19/%E6%9D%A1%E6%AC%BE20%EF%BC%8C%E7%94%A8%E5%BC%95%E7%94%A8%E5%8F%96%E4%BB%A3%E4%BC%A0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="条款20，用引用取代传值"><a href="#条款20，用引用取代传值" class="headerlink" title="条款20，用引用取代传值"></a>条款20，用引用取代传值</h1><p>在默认情况下，对一个函数传值是实际参数的副本为初值，也就是说在函数中的修改只是 修改了其副本。<br>但是调用<code>cpoy</code>操作可能是一项昂贵的动作</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><span class="hljs-keyword">public</span>:Person();<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-keyword">virtual</span> ~Person();<span class="hljs-keyword">private</span>:<span class="hljs-built_in">string</span> name;<span class="hljs-built_in">string</span> address;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Studennt</span>:</span> <span class="hljs-keyword">public</span> Person&#123;<span class="hljs-keyword">public</span>:Student();~Student();getResult();<span class="hljs-keyword">private</span>:<span class="hljs-built_in">string</span> schoolName;<span class="hljs-built_in">string</span> schoolAddress;&#125;</code></pre><p>如果调用<code>bool validateStudent(Student s);</code>首先Student的copy函数会先调用，然后调用两个string的构造函数。copy完成之后，需要调用两个string的析构函数，然后再调用Student的析构函数。类似的，由于存在继承关系，Perso也 需要调用一次构造函数，一个析构函数，两次string的构造函数，两次string的析构函数。</p><p>并且需要 注意的是<code>virtual getResult();</code>函数。这是一个虚函数，由于 多态的存在，当我们调用参数是<code>Person</code>时，我们期望函数中的<code>Person s</code>继承了<code>Student</code>的性质。但是可惜的是，由于copy不管这些，所以还是<code>Person</code>的<code>getResult()</code>,    产生了<strong>对象切割</strong></p><p><strong>代价是昂贵的</strong></p><p>我们可以采用C++的引用解决这些问题。但是需要注意的是传值操作不会改变原有的数据，所以在调用时，我们需要这样定义</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Student&amp; s)</span></span>;</code></pre><blockquote><p>请记住：<br>    尽量以pass-by-reference-to-const替代pass-by-value。前者通常比较高效，并且可以避免切割问题。<br>    以上规则并不是适用于内置类型，已经STL的迭代器和函数对象对他们而言，pass-by-value比较适当。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零碎的笔记</title>
    <link href="/WennyAhhh.github.io/2020/10/19/%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/"/>
    <url>/WennyAhhh.github.io/2020/10/19/%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="零碎笔记"><a href="#零碎笔记" class="headerlink" title="零碎笔记"></a>零碎笔记</h1><h2 id="同步，异步，阻塞，非阻塞"><a href="#同步，异步，阻塞，非阻塞" class="headerlink" title="同步，异步，阻塞，非阻塞"></a>同步，异步，阻塞，非阻塞</h2><p>今天上课听到的一些概念。觉得挺容易混淆的，之前在学习系统编程的时候遇到这些概念，没有系统总结过，经常懵。</p><p><strong>同步和异步</strong></p><p>同步和异步是针对<strong>消息通讯机制</strong>来说的。</p><p>当发生函数调用的时候，在<strong>同步</strong>的情况，当前线程必须要等待函数调用完成，因为这个调用他不发送任何消息，如果不是死等，那么万一错过了就真的错过了。</p><p>在<strong>异步</strong>的情况下，他会在函数调用完成之后发送一个就直接返回了，返回的不是结果。实际处理这个调用的部件在完成后，通过状态，通知和回调函数来通知调用者。简单来说说是会给当前进程一个<strong>通知</strong>  (至于具体的通知形式，emm我只是搬运工</p><p><strong>阻塞和非阻塞</strong></p><p>阻塞和非阻塞是针对<strong>当前队列等待消息通知时的状态</strong>角度来说的。</p><p>当调用函数时，在阻塞状况下，当前线程会被挂起，等待函数返回。</p><p>在非阻塞的状况下，当前线程不会挂起，而会继续处理其他事情。</p><p><strong>同步阻塞/同步非阻塞/异步阻塞/异步非阻塞</strong></p><p>这其实两两组合的啦。</p><p>同步阻塞，发生调用时，当前线程挂起，一直等待调用结束然后唤起。</p><p>同步非阻塞, 发生调用时，当前线程可以去干别的事情，但是由于没有消息通知，所以要过一段时间去检测调用是否完成。</p><p>异步阻塞，发生调用时，当前线程挂起，一直等待调用结束，发了一个通知再唤醒。</p><p>异步非阻塞，发生调用时，当前线程干别的事情，当调用结束，接收到了通知，当前线程就会处理。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程学习（一）</title>
    <link href="/WennyAhhh.github.io/2020/10/12/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
    <url>/WennyAhhh.github.io/2020/10/12/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="C-多线程学习（一）"><a href="#C-多线程学习（一）" class="headerlink" title="C++多线程学习（一）"></a>C++多线程学习（一）</h1><p>C++11中加入了<thread>头文件，此头文件主要声明了std::thread线程类。C++11的标准类std::thread对线程进行了封装，定义了C++11标准中的一些表示线程的类、用于互斥访问的类与方法等。应用C++11中的std::thread便于多线程程序的移值。</p><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;do_something&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_something_else</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;do_something_else&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">background_task</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//仿函数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;do_something();do_something_else();&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;background_task f;    <span class="hljs-comment">//加入线程</span>    <span class="hljs-comment">//callable,可调用对象，将带有函数调用符类型的实例传入std::thread类中，替换默认的构造函数</span><span class="hljs-function">thread <span class="hljs-title">my_thread</span><span class="hljs-params">(f)</span></span>;    <span class="hljs-comment">//等待my_thread线程结束</span>my_thread.join();    <span class="hljs-comment">//分离线程</span>    my_thread.detach();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如果传递的是一个临时变量（右值），比如函数的返回值，编译器就会解析为函数声明，而不是我们期望的类型对象。所以在调用的时候，有三种方式</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">my_thread</span><span class="hljs-params">((background_task()))</span></span>;<span class="hljs-comment">//()包起来</span><span class="hljs-built_in">std</span>::thread my_thread&#123;background_task()&#125;;<span class="hljs-comment">//&#123;&#125;将函数名包含住</span><span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">my_thread</span><span class="hljs-params">([]&#123;<span class="hljs-comment">//lanbda表达式</span></span></span><span class="hljs-function"><span class="hljs-params">    do_something();</span></span><span class="hljs-function"><span class="hljs-params">    do_something_else();</span></span><span class="hljs-function"><span class="hljs-params">&#125;)</span></span></code></pre><p>先提一下名字：<code>父进程</code>，创建了其他进程的进程。上例来说，main是父进程。<code>子进程</code>，被父进程创建出来的进程。上例’<code>f</code>调用的仿函数为子进程，do_something和do_something_else为一个线程。</p><p>这样就完成了线程的启动工作。如果将代码中的<code>my_thread.join()</code>删除，程序可能不会正常运行。你需要明确在父线程结束前，是否要让my_thread线程加入(<code>join</code>),还是分离(<code>detach</code>)。先暂时放开这两个名词。想象</p><blockquote><p>1.如果子线程还没有运行完成，但是父线程已经销毁了，那么这个线程该去哪里？变成了孤儿线程。</p><p>2.如果子线程已经运行完成了，但是父线程还在运行或者父线程没有清理（wait）子线程，那么子线程是什么状态？僵尸进程。</p><p>3.如果线程在运行时使用了共享资源，即父线程和子线程使用了同样的资源。如果父线程销毁了资源，或者是子线程这样干了，会导致程序出错。</p></blockquote><p>所以我们需要在父线程中管理子线程。</p><h2 id="等待线程完成"><a href="#等待线程完成" class="headerlink" title="等待线程完成"></a>等待线程完成</h2><p>如果需要线程等待，需要使用<code>join()</code>。当启动线程后，在父线程中可以干自己的事，子线程也有自己的工作要做。<code>join</code>是简单粗暴的等待线程完成或不等待。当你需要对等待中的线程有更灵活的控制时，比如，看一下某个线程是否结束，或者只等待一段时间（超过一段时间就判定为超时)。</p><p><code>join</code>还清理了线程相关的储存部分(调用了wait来清理以结束的子进程)，避免出现僵尸进程。这样对象将不再与已经完成的线程有任何关联。所以对一个线程只能使用一次<code>join()</code>,可以用<code>joinable()</code>返回的布尔值判断是否已经调用了<code>join</code>。</p><p>就想锁和new一样，这样两两对应操作总是不友好的操作。可能在运行到一半时返回异常，也可能忘记了。所以完全可以使用<code>RAII</code>的内存管理方式解决这个问题（在智能指针的博文中我有详细的介绍）</p><pre><code class="hljs cpp"><span class="hljs-comment">//防止调用拷贝函数，私有继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Uncopyable</span> &#123;</span><span class="hljs-keyword">protected</span>:Uncopyable() &#123;&#125;~Uncopyable() &#123;&#125;<span class="hljs-keyword">private</span>:Uncopyable(<span class="hljs-keyword">const</span> Uncopyable&amp;);Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Uncopyable&amp;);&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thread_guard</span> :</span> <span class="hljs-keyword">private</span> Uncopyable&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">std</span>::thread&amp; t;<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread_guard</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::thread&amp; t_)</span> :<span class="hljs-title">t</span><span class="hljs-params">(t_)</span> </span>&#123;&#125;~thread_guard() &#123;<span class="hljs-keyword">if</span> (t.joinable()) &#123;<span class="hljs-comment">//如果还没有加入过 </span>t.join();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;调用析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;    <span class="hljs-comment">//C++ 11提供了=delete方式禁止方法调用</span>    <span class="hljs-comment">//thread_guard(thread_guard const&amp;) = delete;</span><span class="hljs-comment">//thread_guard&amp; operator=(thread_guard const&amp;) = delete;</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;background_task f;<span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(f)</span></span>;<span class="hljs-function">thread_guard <span class="hljs-title">g</span><span class="hljs-params">(t)</span></span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="转移线程所有权"><a href="#转移线程所有权" class="headerlink" title="转移线程所有权"></a>转移线程所有权</h2><p>有时候线程的所有权需要转移。</p><p>C++标准库中有很多资源（resource-owning）类型，比如<code>std::ifstream,std::unique_ptr</code>还有<code>std::thread</code>都是可移动类型，但是不可拷贝。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_other_function</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t1</span><span class="hljs-params">(some_function)</span></span>;<span class="hljs-comment">//在使用move之后，相当于资源被另外一个变量拥有了，t1会自动置为NULL</span><span class="hljs-built_in">std</span>::thread t2 = <span class="hljs-built_in">std</span>::move(t1);t1 = <span class="hljs-built_in">std</span>::thread(some_other_function);<span class="hljs-built_in">std</span>::thread t3;t3 = <span class="hljs-built_in">std</span>::move(t2);<span class="hljs-comment">//程序会崩溃</span>t1 = <span class="hljs-built_in">std</span>::move(t3);</code></pre><h2 id="运行时决定线程数量"><a href="#运行时决定线程数量" class="headerlink" title="运行时决定线程数量"></a>运行时决定线程数量</h2><p>书中提供一个例子，用多线程计算一个容器里所有类的和，例如计算<code>vector&lt;int&gt;</code>中所有整型之和。每个线程计算其中的一部分，然后全部加起来。因为不能直接从一个线程中返回一个值，所以需要传递results容器的引用到线程中去。</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator,<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">accumulate_block</span>&#123;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Iterator first, Iterator last, T&amp; result)</span> </span>&#123;<span class="hljs-comment">//从fist到last加起来再加上初始值</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;accumulate:   &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="hljs-built_in">endl</span>;result = <span class="hljs-built_in">std</span>::accumulate(first, last, result);&#125;&#125;;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator,<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">parallel_accumulate</span><span class="hljs-params">(Iterator first, Iterator last, T init)</span> </span>&#123;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">std</span>::distance(first, last);<span class="hljs-keyword">if</span> (!length) &#123;<span class="hljs-comment">//如果为0，也就是说输入范围为0</span><span class="hljs-keyword">return</span> init;&#125;<span class="hljs-comment">//设置最小的任务量</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> min_per_thread = <span class="hljs-number">25</span>;<span class="hljs-comment">//设置最大的线程数</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> max_threads = (length + min_per_thread - <span class="hljs-number">1</span>) / min_per_thread;<span class="hljs-comment">//返回这个函数能够同时并发的线程数量</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> hardware_threads = <span class="hljs-built_in">std</span>::thread::hardware_concurrency();    <span class="hljs-comment">//开几个线程</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> num_threads = min(hardware_threads != <span class="hljs-number">0</span> ? hardware_threads : <span class="hljs-number">2</span>, max_threads);    <span class="hljs-comment">//每个线程需要计算的区间大小。因为是向下取整的，所以for循环结束之后还还有一个区间需要加起来</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> block_size = length / num_threads;<span class="hljs-comment">//存放临时变量的地方</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">results</span><span class="hljs-params">(num_threads)</span></span>;<span class="hljs-comment">//开的线程都放在这边，注意要-1，因为还有一个主线程。</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; <span class="hljs-title">threads</span><span class="hljs-params">(num_threads - <span class="hljs-number">1</span>)</span></span>;Iterator block_start = first;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; (num_threads - <span class="hljs-number">1</span>); i++) &#123;Iterator block_end = block_start;        <span class="hljs-comment">//把block_end向后前进block_size个单位</span><span class="hljs-built_in">std</span>::advance(block_end, block_size);        <span class="hljs-comment">//开一个线程，记得加ref引用</span>threads[i] = <span class="hljs-built_in">std</span>::thread(accumulate_block&lt;Iterator, T&gt;(),block_start,block_end,<span class="hljs-built_in">std</span>::ref(results[i]));block_start = block_end;&#125;    <span class="hljs-comment">//把余数开个线程加起来</span>accumulate_block&lt;Iterator, T&gt;()(block_start, last, results[num_threads - <span class="hljs-number">1</span>]);<span class="hljs-built_in">std</span>::for_each(threads.begin(), threads.end(), <span class="hljs-built_in">std</span>::mem_fn(&amp;<span class="hljs-built_in">std</span>::thread::join));    <span class="hljs-comment">//把临时区间全部加起来返回</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::accumulate(results.begin(), results.end(), init);&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">21</span>,<span class="hljs-number">12</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">22</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-built_in">cout</span> &lt;&lt; parallel_accumulate&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator, <span class="hljs-keyword">int</span>&gt;(ans.begin(), ans.end(), <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : ans) &#123;sum += e;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; sum;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="识别线程"><a href="#识别线程" class="headerlink" title="识别线程"></a>识别线程</h2><p>线程标识类型是<code>std::thraed::id</code>，可以通过两种方式进行检索。</p><p>1.可以通过调用<code>std::thread</code>对象的成员函数 <code>get_id()</code>来直接获取。如果没有执行线程，就会返回<code>std::this_thread::type</code>默认构造值（个人测试出来是0)</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-string">&quot;hello&quot;</span> &#125;;<span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(f, <span class="hljs-number">3</span>, buffer)</span></span>;<span class="hljs-built_in">cout</span> &lt;&lt; t.get_id();t.join();</code></pre><p>2.当前线程中调用<code>std::this_thread::get_id()</code>也可以获得线程标识。</p><pre><code class="hljs cpp"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::this_thread::get_id();</code></pre><p>通过线程标识，可以将线程放入容器中，比如<code>std::map&lt;std::thread::id&gt;</code></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-C++并发编程学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能指针的粗浅总结</title>
    <link href="/WennyAhhh.github.io/2020/10/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%B2%97%E6%B5%85%E6%80%BB%E7%BB%93/"/>
    <url>/WennyAhhh.github.io/2020/10/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%B2%97%E6%B5%85%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="智能指针的粗浅总结"><a href="#智能指针的粗浅总结" class="headerlink" title="智能指针的粗浅总结"></a>智能指针的粗浅总结</h1><hr><p>&emsp;所谓资源就是,一旦向系统申请内存并且成功，则在使用完后还给进程。但是内存管理一直是C++麻烦的点。忘了delete,delete之后指针没有指向NULL，程序在delete之前抛出异常，对同一对象多次析构，等等痛点。我自己在学习Qt智能指针，以及之前做项目的时候遇上的内存泄露问题，使用了智能指针，但是只是知道有这个而已，没有系统总结过。对于此，查看了很多资料，略微总结了一下关于智能指针的一些用法以及原理。但是如果深究其中这篇文章是写不完的，所以只是粗略的总结一下。第一次写那么长的博文，会有一些纰漏，谅解一下。。</p><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><blockquote><p>资源取得时机便是初始化时机（Resource Acquisition Is Initialization）RAII要求，<strong>资源的有效期与持有资源的对象的生命期严格绑定</strong>，即由对象的构造函数完成资源的分配（获取），同时由析构函数完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。 –wiki</p></blockquote><p>举个简单的例子。在使用STL容器的时候定<code>vector&lt;int&gt;</code>,<code>vector&lt;int&gt;</code>只是一个变量，源代码中，他在构造函数申请了资源，又使用了析构函数释放资源。<code>res</code>是建立在栈上的，而其申请的资源是放在堆上的，利用语言机制，当<code>res</code>跳出作用域的时候，调用了析构函数，完成了内存释放。</p><p>用effective C++上的一个例子</p><pre><code class="hljs cpp"><span class="hljs-function">FontHandle <span class="hljs-title">getFont</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//工厂函数,取得资源，可以看做使用了new</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseFont</span><span class="hljs-params">(FontHandle fh)</span></span>;   <span class="hljs-comment">//释放资源，可以看做使用了delete</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Font</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span>:<span class="hljs-title">f</span><span class="hljs-params">(fh)</span></span>&#123; <span class="hljs-comment">//构造函数里面申请了资源</span>  &#125;<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;   <span class="hljs-comment">//隐式转换函数，用于获取原始资源，方便调用</span><span class="hljs-keyword">return</span> f;&#125;~Font() &#123;releaseFont(f);<span class="hljs-comment">//析构函数释放资源</span>&#125;<span class="hljs-keyword">private</span>:FontHandle f;&#125;;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//主函数调用</span><span class="hljs-function">Font <span class="hljs-title">f</span><span class="hljs-params">(getFont())</span></span>;  <span class="hljs-comment">//由于是在栈上实例化，所以f在退出作用域的时候会调用析构函数</span><span class="hljs-keyword">int</span> newFontSize;...changFontSize(f,newFontSize);</code></pre><p>当然这只是一个例子，并没有太高的实际意义。实际中，比如多线程之中，封装 <code>Mutex </code>，构造函数加锁，析构函数解锁。这一部分我们后面会再次提到。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>利用RAII的思想，C++提供了智能指针模板，方便使用。<br>常用的智能指针针:<del>auto_ptr</del>, <code>unique_ptr, shared_ptr和weak_ptr</code>。当然Qt,boost 还提供了其他智能指针，这个留到后面细谈。 </p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>先看一段代码</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;auto&quot;</span>))</span></span>; <span class="hljs-comment">//RAII</span><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2;p2=p1;</code></pre><p>这在编译器中是可以通过的，但是<code>p1</code>会被重置为NULL。看上去很合理，因为这防止了多次析构。但是之后再次使用<code>p1</code>，可能会出现一些问题，会导致程序崩溃，这是我们不希望看见的，我们宁愿他在编译期间出错,所以我们<strong>尽量不使用auto_ptr</strong>。那么直接一点，不允许进行赋值操作，那就是<code>unique_ptr</code>。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;auto&quot;</span>))</span></span>; <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2;p2=p1; <span class="hljs-comment">//编译器会报错</span></code></pre><p><code>unique_ptr</code>虽然不允许进行赋值操作，但是凡事都有例外嘛。</p><p>1.如果<code>unique_ptr</code>是<strong>临时</strong>的右值，编译器就允许赋值。</p><pre><code class="hljs cpp"><span class="hljs-comment">//C++ primer plus中的代码</span><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">demo</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;T&quot;</span>))</span></span>;    <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; sp;ps=demo();  <span class="hljs-comment">//demo()先产生一个临时的unique_ptr&lt;string&gt; 变量，然后赋值</span></code></pre><p>2.使用<code>std::move()</code>，其实就是和<code>auto_ptr</code>一样的效果，其中右值在赋值完只有会被置为NULL</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;auto&quot;</span>))</span></span>; <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2;p2=mov(p1); <span class="hljs-comment">//p1会被置为NULL</span></code></pre><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>需求总是多种多样的，我不管我就是需要赋值操作，我的程序就是使用多个指向同一个对象的指针，那么就应该使用shared_ptr，对底层资源使用“引用计数法”，构造的时候+1，赋值的时候+1，析构的时候-1,这个资源的计数器达到0的时候调用析构函数。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;auto&quot;</span>))</span></span>; <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2;p2=p1;    <span class="hljs-comment">//此时p1不为NULL</span></code></pre><p>但是这玩意功能比较多，很容易出错。比较常见的是循环引用问题，还有一些关于多线程下的问题，放在后面一个模块。</p><p>问题代码</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FA</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FA</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">shared_ptr</span>&lt;FB&gt; b;FA()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~FA() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">shared_ptr</span>&lt;FA&gt; a;FB()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;B&#x27;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~FB() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;FA&gt; <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FA())</span></span>;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;FB&gt; <span class="hljs-title">fb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FB())</span></span>;fa-&gt;b = fb;fb-&gt;a = fa;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;fa: &quot;</span> &lt;&lt; fa.use_count() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; <span class="hljs-string">&quot;fb: &quot;</span> &lt;&lt; fb.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp">输出：     A    B    fa: <span class="hljs-number">2</span>  fb: <span class="hljs-number">2</span></code></pre><p>这里会发现，虽然使用了智能指针，但是却并没有调用其析构函数，因为这里产生了一个<strong>闭环</strong>，如果把这个环给拆了，<code>fa-&gt;b = fb;</code>或者<code>fb-&gt;a = fa;</code>删掉一个就可以了，就不展示了。</p><p>你可以把一个构造函数看做<code>&#123;</code>，把一个析构函数看做<code>&#125;</code>，shared_ptr的计数器会在析构函数中自动-1，但是没有动用析构函数，自然就不会-1。再来看这个代码，fa,fb的计数器为2就不加解释了，在fb跳出作用域的时候，fb的计数器-1，但是没有置为0，所以不会调用析构函数，自然fb中的a的计数器不会-1，此时fb的计数器为1，fa的计数器还是为2。然后fa跳出作用域，计数器-1，fa中的b计数器不为0，所以也不调用fb析构函数，也不会调用fa的析构函数。这就导致两个对象到结束，计数器都是为1的。</p><p>解决这个问题，就需要抛出另外一个智能指针weak_ptr</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr一般和shared_ptr配合使用（之前Qt尝试用QWeakPointer代替QPointer，使得QWeakPointer可以独立使用，但是后来又改回来了），用于解除循环引用。</p><p>对于上例，应该改为：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FA</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FA</span> &#123;</span><span class="hljs-keyword">public</span>:weak_ptr&lt;FB&gt; b;FA()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~FA() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span> &#123;</span><span class="hljs-keyword">public</span>:wead_ptr&lt;FA&gt; a;FB()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;B&#x27;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~FB() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;FA&gt; <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FA())</span></span>;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;FB&gt; <span class="hljs-title">fb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FB())</span></span>;fa-&gt;b = fb;fb-&gt;a = fa;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;fa: &quot;</span> &lt;&lt; fa.use_count() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; <span class="hljs-string">&quot;fb: &quot;</span> &lt;&lt; fb.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp">输出：ABfa: <span class="hljs-number">1</span>  fb: <span class="hljs-number">1</span>~B~A</code></pre><p>由此可见一个事实：weak_ptr<strong>不会更改其引用计数</strong>，但是，weak_ptr并没有重载-&gt;,*操作符，如果需要使用weak_ptr封装的对象，需要调用lock()函数，这个函数会返回一个shared_ptr，但是计数器为0，就返回<code>NULL</code></p><p>而我们的任务就是在编译期间解开循环引用，但是并不保证在运行期间也不存在循环引用的问题。</p><h3 id="原始指针"><a href="#原始指针" class="headerlink" title="原始指针"></a>原始指针</h3><p>智能指针一般都提供了<strong>get()成员函数</strong>，用来执行显式转换，也就是它会返回智能指针内部的原始指针（的复件。</p><p>我们**尽量不要使用get()**，因为智能指针的初衷是将原生指针交给他来管理，get()就违背了这个初衷（试验了一下，vs2019的代码补全居然不显示get）。当然为了适配一些函数不得不去使用get，所以我们在使用get的时候需要小心。由于智能指针有些很der的操作我个人觉得在正常情况下不会有人这样去写，但是如果使用了get,在函数中，发生这样der的情况就可能出现：</p><p>1.不要使用相同的内置指针来初始化(或者reset)多个智能指针</p><p>2.不要delete get()返回的指针</p><p>3.不要用get()初始化/reset另一个智能指针</p><p>4.不要把this指针交给智能指针管理</p><p>5.不要把一个原生指针给多个shared_ptr或者unique_ptr管理</p><p>由于篇幅我原因（对，因为我懒），具体的例子我就不写了。。</p><p>如果需要调用成员函数，由于几乎所有的智能指针都重载了*，-&gt;操作符，所以直接使用把智能指针当做一般的指针变量来使用就可以了。但是有时候需要传递参数，如果参数是 T*，那么传递一个智能指针类是无法识别的。有两种方式<br>1.使用原始指针T.get()<br>2.修改函数调用参数，如果是传递一个值，那么use_count()输出是2，如果是传递指针或者引用，use_count()是1。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getResult</span><span class="hljs-params">(FA* fa)</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; fa-&gt;k &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;FA&gt; <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FA(<span class="hljs-number">1</span>))</span></span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数调用前：   &quot;</span> &lt;&lt; fa.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;getResult(fa.get());<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;函数调用后：   &quot;</span>&lt;&lt;fa.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><pre><code class="hljs cpp">输出：A函数调用前：   <span class="hljs-number">1</span><span class="hljs-number">1</span>函数调用后：   <span class="hljs-number">1</span>~A</code></pre><p>在函数传递的过程中，<strong>需要以独立语句将newed对象置入智能指针</strong>(effective C++条款17)</p><pre><code class="hljs cpp">processWidget(<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget),priority());</code></pre><p>例如上述的函数调用，第一个shared_ptr参数分为可以两个部分，并且这个顺序是固定的：</p><p>1.执行<code>new Widget</code>表达式</p><p>2.调用<code>shared_ptr</code>构造函数</p><p>但是由于会有<code>priority()</code>参数的存在，所以会产生这样的操作序列</p><p>1.执行<code>new Widget</code>表达式</p><p>2.调用priority</p><p>3.调用<code>shared_ptr</code>构造函数</p><p>这样，如果在调用<code>priority</code>函数的过程中发生了异常，那么调用<code>shared_ptr</code>就不会执行，没放入到智能指针当中去，造成内存泄露。当然你要是头铁不想动脑筋想一个临时变量的名字，<code>make_unique</code>会满足这个需求。</p><h3 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h3><h4 id="删除器使用"><a href="#删除器使用" class="headerlink" title="删除器使用"></a>删除器使用</h4><p>之前有提到过，可以利用RAII的思想，解决互斥锁可能出现忘记解锁的情况。在effective C++中是这样实现的：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex* _mutexPtr)</span>:<span class="hljs-title">mutexPtr</span><span class="hljs-params">(_mutexPtr)</span> </span>&#123;lock(mutexPtr);  <span class="hljs-comment">//构造函数时锁定</span>&#125;~Lock() &#123;unlock(mutexPtr);<span class="hljs-comment">//析构函数解锁</span>&#125;<span class="hljs-keyword">private</span>:Mutex* mutexPtr;&#125;;</code></pre><pre><code class="hljs cpp">Mutex pm;  <span class="hljs-comment">//设置互斥锁</span>Lock(&amp;pm);</code></pre><p>我们传入一个互斥锁，在构造函数加锁，析构函数解锁。看起来也许就是这样的，但是出现赋值操作时，也就是</p><pre><code class="hljs cpp"><span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;pm)</span></span>;<span class="hljs-function">Lock <span class="hljs-title">m2</span><span class="hljs-params">(m1)</span></span>;</code></pre><p>这样的操作会导致多次析构。所以赋值的操作是灾难性的，你可以选择继承<code>private Uncopyable</code>达到无法赋值的效果，也可以使用shared_ptr。但是选择计数器的方式会产生一个问题：传入一个互斥锁的指针，跳出作用域解锁，并且计数器为0，<strong>删除</strong>这个互斥锁。这是我们不想要的。所以无论是unique_ptr还是shared_ptr都可以指定删除器，默认的删除器是delete。</p><p>对上例进行修改</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex* pm)</span>: <span class="hljs-title">mutexPtr</span><span class="hljs-params">(pm,unlock)</span></span>&#123;        lock(mutexPtr.get());    &#125;    <span class="hljs-keyword">private</span>:    <span class="hljs-built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;&#125;</code></pre><h4 id="不要在没有定义的情况下在函数中使用delete"><a href="#不要在没有定义的情况下在函数中使用delete" class="headerlink" title="不要在没有定义的情况下在函数中使用delete"></a>不要在没有定义的情况下在函数中使用delete</h4><p>shared_ptr的删除器比较简单使用，unique_ptr的第二个删除传的是指针，所以一般传递一个函数指针。本来不算吧这个东西放上去的，但是在调试的时候发现一个很有趣的现象:</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span>;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(FB* fb)</span> </span>&#123;<span class="hljs-keyword">delete</span> fb;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数指针&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uni</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FB* fb)</span> </span>&#123;<span class="hljs-keyword">delete</span> fb;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;仿函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span> &#123;</span><span class="hljs-keyword">public</span>:FB(<span class="hljs-keyword">int</span> _k) :k(_k) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;B&#x27;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~FB() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">int</span> k;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//C++ 11增加的decltype，返回的是类型 </span>unique_ptr&lt;FB, decltype(del)*&gt; ptr1(new FB(2), del);    <span class="hljs-comment">//函数指针</span>unique_ptr&lt;FB, void(*)(FB* )&gt; ptr2(new FB(2), del);    <span class="hljs-comment">//使用仿函数</span>unique_ptr&lt;FB, uni&gt; ptr3(new FB(2));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>跑一下试试</p><pre><code class="hljs cpp">BBB仿函数函数指针函数指针</code></pre><p>发现析构函数没有调用，产生了内存泄露。但是只要把函数或者仿函数放在类的定义之下，或者include “FA.h”,就成功调用了析构函数。</p><p>原因在于，我在前面只声明了FA，但是FA里面有什么成员函数，多大都不知道，是一个不完整类型（Incomplete Type），所以无法触发析构函数。</p><h3 id="为数组设计的智能指针"><a href="#为数组设计的智能指针" class="headerlink" title="为数组设计的智能指针"></a>为数组设计的智能指针</h3><p>STL中没有那种特别为“C++ 动态分配数组”而设计的类似shared_ptr以及unique_ptr的智能指针，原因在于，我们完全可以使用vector等容器来存放这些，所以就完全没有必要。但注意一点是，如果vector中存放的是指针，那么在释放vector的时候不会释放指针指向的资源，此时可以使用智能指针。</p><p>当然如果你痛恨容器或者不屑用它，也可以使用上述的删除器，记得delete[]。</p><p>boost库中提供了这种你需要的东西。boost::scoped_array 和 boost::shared_array </p><h2 id="智能指针的线程安全"><a href="#智能指针的线程安全" class="headerlink" title="智能指针的线程安全"></a>智能指针的线程安全</h2><blockquote><p>引用一下陈硕老师的<a href="https://blog.csdn.net/solstice/article/details/8547547">例子</a></p></blockquote><p>考虑一个简单的场景，有 3 个 shared_ptr<Foo> 对象 x、g、n：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo)</span></span>; <span class="hljs-comment">// 线程之间共享的 shared_ptr</span><span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; x; <span class="hljs-comment">// 线程 A 的局部变量</span><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo)</span></span>; <span class="hljs-comment">// 线程 B 的局部变量</span></code></pre><p><img src="https://i.loli.net/2020/10/11/gez5oHSk1yMJabB.png" alt="image-20201009233059869"></p><p><img src="https://i.loli.net/2020/10/11/wBP7ht1ADp5xQ3u.png" alt="image-20201009233139541"></p><p><img src="https://i.loli.net/2020/10/11/WKlz1mXTPNvODcr.png" alt="image-20201009233346743"></p><p>总结一下，shared_ptr的线程不安全性在于他需要操作两个成员，new出来的对象以及计数器。在多线程下，不能保证new出来一个对象一定能被放入shared_ptr中，也不能保证智能指针管理的引用计数的正确性。究其根本，shared_ptr的操作不是一气呵成的。</p><blockquote><ol><li><p>同一个shared_ptr对象可以被多线程同时读取。</p></li><li><p>不同的shared_ptr对象可以被多线程同时修改。</p></li><li><p>同一个shared_ptr对象不能被多线程直接修改，但可以通过原子函数完成。</p></li></ol></blockquote><p>所以在创建一个shared_ptr的时候，使用C++ 11提供的<code>make_shared</code>模板。make_shared创建shared_ptr只申请一次内存，避免了上述错误，也提高了性能。</p><pre><code class="hljs cpp"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p1 = make_shared&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;9&#x27;</span>);   <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2 = make_shared&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p3 = make_shared&lt;<span class="hljs-built_in">string</span>&gt;();</code></pre><p>当需要读写操作时，需要加锁。</p><p>前面提到的unqiue_ptr也是 如此，虽然没有两个成员，但是在申请内存的时候只申请一次。</p><p>总结一下：<br>    在创建智能智能的时候，<strong>使用make_shared以及unique_shared</strong></p><h2 id="QT智能指针"><a href="#QT智能指针" class="headerlink" title="QT智能指针"></a>QT智能指针</h2><p>QT采用的的是半自动的内存管理机制。parent-chlid机制使QOBject类不需要进行delete，当然，是在指定parent的情况下。QT在引入了对象树的概念。当new一个QObject对象的时，指定其父对象，那么这个对象会加入到父对象的对象树之中。<strong>如果父对象被delete，那么子对象也会被delete</strong><br>但是会存在new的类不是QObject类，或者QObject没有指定父对象，QT提供了多种智能指针，相对于STL库中的智能指针，更加强大，或者说更适合QT。</p><h3 id="QSharedPointer-QScopedPointer"><a href="#QSharedPointer-QScopedPointer" class="headerlink" title="QSharedPointer/QScopedPointer"></a>QSharedPointer/QScopedPointer</h3><p>QSharedPointer类似于std::shared_ptr,QScopedPointer类似于std::unique_ptr，用法也是类似的。这边就不再赘述。</p><p>相对的，QT也提供了make_shared的替代，为QSharedPointer制作智能指针，利用完美转发，只分配一次内存。</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> ptr = QSharedPointer&lt;QPushButton&gt;::create(<span class="hljs-string">&quot;Cancel&quot;</span>, <span class="hljs-keyword">this</span>);</code></pre><h3 id="QScopedArrayPointer"><a href="#QScopedArrayPointer" class="headerlink" title="QScopedArrayPointer"></a>QScopedArrayPointer</h3><p>QT也提供了自动释放数组的智能指针</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><span class="hljs-function">  </span>&#123;      <span class="hljs-function">QScopedArrayPointer&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>])</span></span>;      i[<span class="hljs-number">2</span>] = <span class="hljs-number">42</span>;      ...      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// our integer array is now deleted using delete[]</span>  &#125;</code></pre><h3 id="QWeakPointer"><a href="#QWeakPointer" class="headerlink" title="QWeakPointer"></a>QWeakPointer</h3><p>和weak_ptr一样，为了配合QSharedPointer引入的智能指针，有趣的是，曾经QWeakPointer取代过QPointer，但是已经是曾经啦，有兴趣的话可以查看此<a href="https://www.devbean.net/2012/09/continue-using-qpointer/">链接</a></p><h3 id="QSharedDataPointer"><a href="#QSharedDataPointer" class="headerlink" title="QSharedDataPointer"></a>QSharedDataPointer</h3><p>侵入式智能指针，用于进行<strong>隐式共享</strong>。隐式共享会即写时拷贝，常见的例子是string类。他是一个特殊的引用。例如</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<span class="hljs-built_in">string</span> s2=s1;<span class="hljs-built_in">string</span> s2=<span class="hljs-string">&quot;world&quot;</span>;</code></pre><p>在第二行进行赋值操作时，进行的是浅拷贝，共享一个资源。但是在第三行需要进行重新赋值或者修改时，才需要将s1的资源拷贝过来放在s2中，并且修改。</p><p>QSharedDataPointer做的工作类似。需要注意的是，复制过来的只有智能指针管理的资源，而不包括计数器。如果变量超出作用域，也会自动调用析构函数。</p><p>在使用QSharedDataPointer模板时，必须继承QSharedData，实现隐式共享</p><p>例子</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> :</span> <span class="hljs-keyword">public</span> QSharedData&#123;<span class="hljs-keyword">public</span>:    A(QString _str):str(_str)&#123;    &#125;    A(<span class="hljs-keyword">const</span> A&amp; other):QSharedData(other),str(other.str)&#123;    &#125;    QString str;&#125;;</code></pre><pre><code class="hljs cpp">A* a=<span class="hljs-keyword">new</span> A(<span class="hljs-string">&quot;Wathc&quot;</span>);QSharedDataPointer&lt;A&gt;p1(a);<span class="hljs-function">QSharedDataPointer&lt;A&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;p2-&gt;str=<span class="hljs-string">&quot;QCV&quot;</span>;qDebug()&lt;&lt;p1-&gt;str;qDebug()&lt;&lt;p2-&gt;str;</code></pre><pre><code class="hljs cpp">输出<span class="hljs-string">&quot;Wathc&quot;</span><span class="hljs-string">&quot;QCV&quot;</span></code></pre><h3 id="QExplicitlySharedDataPointer"><a href="#QExplicitlySharedDataPointer" class="headerlink" title="QExplicitlySharedDataPointer"></a>QExplicitlySharedDataPointer</h3><p>QExplicitlySharedDataPointer和QSharedPointer相反，他是<strong>显式共享</strong>，需要调用<code>detach()</code>函数，才能写时复制，不然和QSharedPointer一样，使用同一资源。具体用法</p><pre><code class="hljs cpp">QExplicitlySharedDataPointer&lt;A&gt;p1(a);<span class="hljs-function">QExplicitlySharedDataPointer&lt;A&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;p2.detach();p2-&gt;str=<span class="hljs-string">&quot;QCV&quot;</span>;qDebug()&lt;&lt;p1-&gt;str;qDebug()&lt;&lt;p2-&gt;str;</code></pre><pre><code class="hljs cpp">如果加了p2.detach();<span class="hljs-string">&quot;Wathc&quot;</span><span class="hljs-string">&quot;QCV&quot;</span>如果不加<span class="hljs-string">&quot;QCV&quot;</span><span class="hljs-string">&quot;QCV&quot;</span></code></pre><h3 id="QPointer"><a href="#QPointer" class="headerlink" title="QPointer"></a>QPointer</h3><p>QPointer与其他智能指针不同，他只能接受QOBject和QOBject的子类。他在跳出作用域的时候不会自动调用析构函数。如果QOBject类没有指定父类，那么就需要手动Delete。</p><p> 当QPointer<strong>跟踪的对象被析构了以后，任何共享其资源的指针，都会被自动置空</strong>，很好地防止了悬空指针。</p><pre><code class="hljs cpp">QPointer&lt;QPushButton&gt; ptr=<span class="hljs-keyword">new</span> QPushButton;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智能指针</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法(二) Dijkstra算法</title>
    <link href="/WennyAhhh.github.io/2020/10/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E4%BA%8C/"/>
    <url>/WennyAhhh.github.io/2020/10/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径算法（二）-Dijkstra算法"><a href="#最短路径算法（二）-Dijkstra算法" class="headerlink" title="最短路径算法（二）  Dijkstra算法#"></a>最短路径算法（二）  Dijkstra算法#</h1><hr><blockquote><p>数据结构课应该都学过这个算法，采用贪心的策略，适用于两点之间的最短距离</p></blockquote><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>1.选定一个父节点，然后遍历其所有的子节点，那么可以算出：子节点距离=min（已经记录的子节点距离，父节点距离+父节点到子节点的距离）。<br>2.采用一个容器，把上述条件中满足 min中后者条件的节点存进去，遍历结束后，在容器中选出一个最小的距离，并且这个没有被标记过，那么这个距离就应该是原点到这个节点的最短距离，并且标记。<br>3.假设这个距离不是最短的距离，那么这个最短的距离应该早就被取出来标记了。<br>4.就按照这样重复下去，取出来的一定是最短的距离，标记好，并且依靠这个最短的距离不断更新在容器中其他没有标记好的最短距离。<br>5.这个容器可以选择一个最小堆，利用STL库中的优先队列(priority_queue)</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><pre><code class="hljs cpp"><span class="hljs-comment">//v标记，dis储存最短路径</span><span class="hljs-keyword">int</span> v[N],dis[M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; q;<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<span class="hljs-built_in">memset</span>(v,<span class="hljs-literal">false</span>,<span class="hljs-keyword">sizeof</span> v);dis[u]=<span class="hljs-number">0</span>;q.push(&#123;<span class="hljs-number">0</span>,u&#125;);<span class="hljs-keyword">while</span>(!q.empty())&#123;<span class="hljs-keyword">int</span> x=q.top().second;q.pop();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=nex[i])&#123;<span class="hljs-keyword">int</span> j=edge[i],w=weight[i];<span class="hljs-keyword">if</span>(dis[x]+w&lt;dis[j])&#123;dis[j]=dis[x]+w;q.push(&#123;-dis[j],j&#125;);&#125;&#125;&#125;&#125;</code></pre><blockquote><p>时间复杂度从简计算，一个点放进去，通过最小堆再拿出来，需要logn的时间，有n个点，时间复杂度是O(nlogn)。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法（一）</title>
    <link href="/WennyAhhh.github.io/2020/10/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E4%B8%80/"/>
    <url>/WennyAhhh.github.io/2020/10/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径算法（一）"><a href="#最短路径算法（一）" class="headerlink" title="最短路径算法（一）"></a>最短路径算法（一）</h1><p>2020/10/2 10:13:30</p><hr><h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><ol><li>在图中，确定一个起点，然后从起点出发到所有点的<strong>最短距离</strong>。</li><li>两点之间存在<strong>负边</strong></li><li>针对整张图来说，<strong>任意两点</strong>之间的距离最短</li></ol><p>针对以上三个问题，有三种算法模板可以使用</p><ul><li>Dijkstra算法</li><li>spfa算法</li><li>Floyd算法</li></ul><h2 id="前置代码"><a href="#前置代码" class="headerlink" title="前置代码"></a>前置代码</h2><p>图的表示方法比较常用的有邻接表和邻接矩阵，都是可行的。一般来说，有时候题目给出的节点值一般为0~n-1，所以在构建图的时候，可以采用一个一维数组来储存。（当然如果不满足调节也可以使用，只不过需要一个映射）</p><p>ps：我们老师讲过节点和结点的概念是不同的，但是文科渣渣以输入法为准。。</p><h3 id="先贴代码"><a href="#先贴代码" class="headerlink" title="先贴代码~"></a>先贴代码~</h3><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1010</span>;   <span class="hljs-comment">//N为节点的数量</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M=N*N+<span class="hljs-number">10</span>; <span class="hljs-comment">//边的数量</span><span class="hljs-keyword">int</span> edge[M],head[N],nex[M],weight[N];<span class="hljs-comment">//edge数组是存储边的</span><span class="hljs-comment">//head数组储存以x节点起点位置</span><span class="hljs-comment">//nex数组将一个点的所有子节点串在一起</span><span class="hljs-comment">//weight权值</span><span class="hljs-keyword">int</span> t;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> w)</span></span>&#123;    edge[++t]=x,weight[N]=w,nex[t]=head[x],head[x]=t;&#125;</code></pre><p>如果需要遍历，比方说从x节点遍历所有的x的子节点</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=nex[i])&#123;<span class="hljs-keyword">int</span> j=edge[i],w=weight[i];<span class="hljs-comment">//j为下一个子节点，w为两点之间的权值</span>......&#125;</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>主要是明白了每个数组的作用，这种储存方式就好解决了</p></blockquote><p>设定一组输入</p><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">10</span><span class="hljs-symbol">0 </span><span class="hljs-number">4</span> <span class="hljs-number">11</span><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">15</span><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">13</span><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">12</span></code></pre><p>一个很简单的树，按照这样的方式，首先由于全局变量所有数组置为0。然后调用add函数，此时的数组为：</p><p><img src="https://i.loli.net/2020/10/02/RcaMh2d8pfU7jDB.png" alt="第一.png"></p><p>然后第二次输入，此时edge[2],应该改为4，nex[2]改为1，head[0]改为2。</p><p><img src="https://i.loli.net/2020/10/02/fyjCNAvZFpuhWl7.png" alt="secon.png"></p><p>由此可见，edge虽然和nex共享一个t，但是edge储存的是真实的子节点，nex中储存的是这个父节点上一个字节点对应的t值。nex数组将一个父节点的全部子节点串起来，head数组储存最后一个子节点，也是所有子节点‘串’的开头。当所有输入完成时，应该是这样的：<br><img src="https://i.loli.net/2020/10/02/uLPtOXavHTxJV49.png" alt="_CN8J4N7_BO~DA_X_01_3D0.png"></p><blockquote><p>注意，题目是无向图的时候，需要调用<strong>两次</strong>,add(x,y,w),add(y,x,w).之前很久没用，血的教训。<br>其实这个东西因为很短，背就完事了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
