<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>go 接口与反射</title>
    <link href="/WennyAhhh.github.io/2021/03/13/%E5%8F%8D%E5%B0%84/"/>
    <url>/WennyAhhh.github.io/2021/03/13/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>例子来源： <a href="https://refactoringguru.cn/design-patterns/abstract-factory/go/example">https://refactoringguru.cn/design-patterns/abstract-factory/go/example</a></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>首先 <strong>interface 是一种类型</strong>，从它的定义可以看出来用了 type 关键字，更准确的说 interface 是一种<strong>具有一组方法的类型</strong>，这些方法定义了 interface 的行为。</p><p>定义一个<code>iShirt</code>接口</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> iShirt <span class="hljs-keyword">interface</span> &#123;setLogo(logo <span class="hljs-keyword">string</span>)setSize(size <span class="hljs-keyword">int</span>)getLogo() <span class="hljs-keyword">string</span>getSize() <span class="hljs-keyword">int</span>&#125;</code></pre><p>对于接口的继承， 感觉Go比较随意</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> shirt <span class="hljs-keyword">struct</span> &#123;logo <span class="hljs-keyword">string</span>size <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shirt)</span> <span class="hljs-title">setLogo</span><span class="hljs-params">(logo <span class="hljs-keyword">string</span>)</span></span> &#123;s.logo = logo&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shirt)</span> <span class="hljs-title">setSize</span><span class="hljs-params">(size <span class="hljs-keyword">int</span>)</span></span> &#123;s.size = size&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shirt)</span> <span class="hljs-title">getLogo</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> s.logo&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shirt)</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> s.size&#125;</code></pre><p>以上就完成了对<code>iShirt</code>接口的继承。 但是在<code>shirt</code>中并没有出现关于接口的信息， 只是对接口中的所有方法重新实现了一遍</p><p>当然， 如果满足了接口的条件， 那么在<code>c++</code>等oo中重要的<strong>多态</strong>自然也是存在的。 </p><pre><code class="hljs go"><span class="hljs-keyword">var</span> v iShirt<span class="hljs-keyword">var</span> s shirtv = s</code></pre><blockquote><p>Golang 将interface作为一种类型， 并且不依赖继承， 而是以一种类似于duck-typing的实现。</p><p>所谓duck-typing， 是一种动态类型风格：</p><p>当一个obj走起来像鸭子， 游泳起来像鸭子， 叫起来也像鸭子，那么就可以被称为鸭子</p></blockquote><p>真甜美的生动形象</p><h2 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h2><p>空<code>interface</code>是一种非常特殊的<code>interface</code>类型， 他没有指定任何方法集， 如此， 任意类型都可以声称实现了空接口， 那么接口变量也就可以存储任意值。</p><p><del>这是书上的原话， 但是这个如此， 我并没有看到什么因果关系。 对于<code>interface</code>来说， 应该只能存在方法， 但是空的<code>interface</code>却可以<strong>存储任意值</strong></del></p><p>储存的任意值的意思是传入的参数， 而非<code>interface</code>声明</p><p><code>var emptyInf interface()</code></p><h2 id="Go-语言interface底层实现"><a href="#Go-语言interface底层实现" class="headerlink" title="Go 语言interface底层实现"></a>Go 语言interface底层实现</h2><p>Go的<code>interface</code>有两种类型： <code>eface</code>和<code>iface</code>。</p><p>Go的interface源码存放在<code>$GOROOT/src/runtime/</code>文件夹中，相关结构体存放在<code>$GOROOT/src/runtime/runtime2.go</code>, </p><p>在<code>interface</code>中都会有存储值，但是存储的是传入变量的值， </p><h3 id="eface-不含任何方法的interface"><a href="#eface-不含任何方法的interface" class="headerlink" title="eface 不含任何方法的interface{}"></a>eface 不含任何方法的interface{}</h3><p>具体结构</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210311223402898.png" alt="image-20210311223402898"></p><p><code>_type</code>是Go语言类型的运行时表示。 几乎所有的语言都可以抽象成为<code>_type</code>。</p><p><code>data</code>是指向具体数据的指针</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> A <span class="hljs-keyword">interface</span>&#123;&#125;    A = <span class="hljs-number">100</span>        v := reflect.ValueOf(A)&#125;</code></pre><p>使用gdb断点， 查看A的值</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210311225059588.png" alt="image-20210311225059588"></p><p>以上就是两个数据指向的地址， 可以查看两者的具体值：</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210311225237353.png" alt="image-20210311225237353"></p><p>对于<code>data</code>， 指向的就是<code>100</code>这个数据， 对于<code>_type</code>数据居然是8(这不是一个结构体么？), 通过<code>bomb</code>实验的直觉， 可能是后面还有数据？</p><p>查看<code>_type</code>的结构体</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> _type <span class="hljs-keyword">struct</span> &#123;size       <span class="hljs-keyword">uintptr</span> ptrdata    <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// size of memory prefix holding all pointers</span>hash       <span class="hljs-keyword">uint32</span>tflag      tflagalign      <span class="hljs-keyword">uint8</span>fieldalign <span class="hljs-keyword">uint8</span>kind       <span class="hljs-keyword">uint8</span>alg        *typeAlg<span class="hljs-comment">// gcdata stores the GC type data for the garbage collector.</span><span class="hljs-comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span><span class="hljs-comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span>gcdata    *<span class="hljs-keyword">byte</span>str       nameOffptrToThis typeOff&#125;</code></pre><p>12个数据， 考虑字节对齐，先打印24个字节</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210311230231964.png" alt="image-20210311230231964"></p><p>这个8应该对应的是size，也就是8个字节， 对应类型<code>int32</code></p><p>验证，修改之后：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> k <span class="hljs-keyword">int8</span> = <span class="hljs-number">4</span>A = k</code></pre><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210312073647745.png" alt="image-20210312073647745"></p><p>可以看见size为一个字节</p><p>后面还有指针， 但是觉得没有必要继续查看下去了。</p><p>总之， <code>interface&#123;&#125;</code>是特殊的。 如果不对<code>_type</code>进行深度挖掘， 原理比较简单</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210311230606459.png" alt="image-20210311230606459"></p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210312085644404.png" alt="image-20210312085644404"></p><h3 id="iface-包含方法"><a href="#iface-包含方法" class="headerlink" title="iface 包含方法"></a>iface 包含方法</h3><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210311223434840.png" alt="image-20210311223434840"></p><p>这个<code>interface</code>包含了方法， 所以包含了一个方法集。 我一开始以为是和C++的虚表一样。后来发现还是不一样的。</p><p><code>iface</code>的整体结构</p><p><img src="C:\Users\11319\AppData\Roaming\Typora\typora-user-images\image-20210313113024859.png" alt="image-20210313113024859"></p><p>和<code>eface</code>来说， 庞杂了很多。我<strong>猜想</strong>这也是为什么要引入<code>eface</code>的原因。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> iShirt <span class="hljs-keyword">interface</span> &#123;getLogo() <span class="hljs-keyword">string</span>getSize() <span class="hljs-keyword">int</span>&#125;<span class="hljs-keyword">type</span> iShoe <span class="hljs-keyword">interface</span> &#123;isTrue() <span class="hljs-keyword">bool</span>&#125;<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">getLogo</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;getLogo&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">12</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">isTrue</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;p := &amp;Person&#123;<span class="hljs-string">&quot;chaij&quot;</span>&#125;<span class="hljs-keyword">var</span> shirt iShirt = p<span class="hljs-keyword">var</span> shoe iShoe = pfmt.Println(shirt.getLogo())fmt.Println(shirt.getSize())fmt.Println(shoe.isTrue())fmt.Println(<span class="hljs-string">&quot;x&quot;</span>)&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210313114252333.png" alt="image-20210313114252333"></p><p>可以使用gdb查看<code>interface</code></p><pre><code class="hljs shell">(gdb) p shirt<span class="hljs-meta">$</span><span class="bash">1 = &#123;tab = 0x4dc520 &lt;Person,main.iShirt&gt;, data = 0xc000010200&#125;</span>(gdb) p shoe<span class="hljs-meta">$</span><span class="bash">2 = &#123;tab = 0x4dc480 &lt;Person,main.iShoe&gt;, data = 0xc000010200&#125;</span>(gdb) p p<span class="hljs-meta">$</span><span class="bash">3 = (main.Person *) 0xc000010200</span></code></pre><p>查看<code>0x000010200</code>这个地址</p><pre><code class="hljs shell">(gdb) x 0xc0000102000xc000010200:   0x004bd198(gdb) x/5c 0x004bd1980x4bd198:       99 &#x27;c&#x27;  104 &#x27;h&#x27; 97 &#x27;a&#x27;  105 &#x27;i&#x27; 106 &#x27;j&#x27;</code></pre><p>可见， 以上的<code>data</code>的地址是相同的，也就是共享内存的。<del>那么他会是写时复制吗？虽然我认为不会是。做了实验， 但是确实不是，而且觉得没有意义不贴上了</del></p><p>然后我想看一下这个方法集</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210313120545136.png" alt="image-20210313120545136"></p><p>shoe相同的操作方法， 不赘述。<code>inter</code>和<code>_type</code>没必要深究，只要知道<strong>表示类型</strong>就行。除非真的闲</p><h2 id="反射定律"><a href="#反射定律" class="headerlink" title="反射定律"></a>反射定律</h2><p><code>interface</code>无论是<code>iface</code>或者是<code>eface</code>， 都有一个<code>(value, type)</code>的对。而反射就是操纵这个<code>interface</code>的这个<code>(value, type)</code>的机制。</p><h3 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h3><p><code>reflect</code>包中提供了<code>reflect.Type</code>和<code>reflect.Value</code>两个类型， 分别表示<code>interface</code>中的<code>value</code>和<code>type</code></p><p>例如<code>iface</code>中的<code>tab</code>包含了类型信息， <code>data</code>包含了内容。 当然<code>reflect</code>不是输出这两个内容</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ValueOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Value</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TypeOf</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Type</span></span></code></pre><pre><code class="hljs go">t := reflect.TypeOf(shirt)v := reflect.ValueOf(shirt)fmt.Println(t, <span class="hljs-string">&quot;   &quot;</span>, v)rt := reflect.TypeOf(t)rv := reflect.ValueOf(t)fmt.Println(rt, <span class="hljs-string">&quot;  &quot;</span>, rv)</code></pre><pre><code class="hljs shell">*main.Person     &amp;&#123;chaij&#125;*reflect.rtype    *main.Person</code></pre><h3 id="第一定律"><a href="#第一定律" class="headerlink" title="第一定律"></a>第一定律</h3><p><strong>反射可以将<code>interface</code>类型变量转换成反射对象</strong></p><p>反射对象：<code>reflect.TypeOf()</code>或<code>reflect.ValueOf()</code>的返回值</p><pre><code class="hljs go">t := reflect.TypeOf(p)v := reflect.ValueOf(p)fmt.Println(t, <span class="hljs-string">&quot;   &quot;</span>, v)rt := reflect.TypeOf(t)rv := reflect.ValueOf(t)fmt.Println(rt, <span class="hljs-string">&quot;  &quot;</span>, rv)</code></pre><pre><code class="hljs shell">*main.Person     &amp;&#123;chaij&#125;*reflect.rtype    *main.Person</code></pre><p>这里的p是<code>Person</code>类型， 没有向上转型为<code>interface</code>。但是在这里依然可以穿<code>reflect.TypeOf()</code>。 可以转为<code>interface</code>对象</p><p>在传入的时候 实际上做了一次转换， <code>x</code>变量被转换成为一个<strong>空接口</strong><code>interface&#123;&#125;</code>传入，<code>reflect.ValueOf()</code>也是一样</p><p>这是<code>reflect.TypeOf reflect.ValueOf</code>特有的， 还是默认的？（默认的， 后续会有实验）</p><h3 id="第二定律"><a href="#第二定律" class="headerlink" title="第二定律"></a>第二定律</h3><p><strong>反射可以将反射对象还原成<code>interface</code>对象</strong></p><p>之所以叫做反射， 是因为反射对象与<code>interface</code>对象是可以互相转化的。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getInterface</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;v := reflect.ValueOf(i)j := v.Interface()<span class="hljs-keyword">if</span> i == j &#123;fmt.Println(<span class="hljs-string">&quot;same&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> x <span class="hljs-keyword">int32</span> = <span class="hljs-number">29</span>getInterface(x)&#125;</code></pre><p>输出：</p><pre><code class="hljs shell">same</code></pre><p>第一， 可见函数传入的时候<code>interface</code>可以默认转化</p><p>第二， 反射对象：v，也就是<code>reflect.TypeOf()</code>或<code>reflect.ValueOf()</code>的返回值。 <code>interface</code>对象: i, j。</p><h3 id="第三定律"><a href="#第三定律" class="headerlink" title="第三定律"></a>第三定律</h3><p><strong>反射对象可修改， value值必须是可设置的</strong></p><p>通过指针。 如果是传值的就无法修改本身</p><p>我们可以通过<code>reflect.Value</code>的一系列<code>SetXXX</code>修改对象值</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">float32</span> = <span class="hljs-number">3.4</span>vv := reflect.ValueOf(&amp;x)vv.Elem().SetFloat(<span class="hljs-number">7.1</span>)fmt.Println(x)</code></pre><p>输出：</p><pre><code class="hljs shell">7.1</code></pre><p>如果是自定义类。 如何设置？</p><h2 id="interface-的实现者的receiver如何选择"><a href="#interface-的实现者的receiver如何选择" class="headerlink" title="interface 的实现者的receiver如何选择"></a>interface 的实现者的receiver如何选择</h2><p>interface 定义时并没有严格规定实现者的方法 receiver 是个 value receiver 还是 pointer receiver。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-keyword">type</span> iShirt <span class="hljs-keyword">interface</span> &#123;getLogo() <span class="hljs-keyword">string</span>getSize() <span class="hljs-keyword">int</span>&#125;<span class="hljs-keyword">type</span> iShoe <span class="hljs-keyword">interface</span> &#123;isTrue() <span class="hljs-keyword">bool</span>&#125;<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">getLogo</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;getLogo&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">12</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span> <span class="hljs-title">isTrue</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;p := Person&#123;<span class="hljs-string">&quot;chaij&quot;</span>&#125;<span class="hljs-keyword">var</span> shirt iShirt = p<span class="hljs-keyword">var</span> shoe iShoe = pfmt.Println(shirt.getLogo())fmt.Println(shirt.getSize())fmt.Println(shoe.isTrue())&#125;</code></pre><p>所示代码会出现问题：</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210313181739583.png" alt="image-20210313181739583"></p><p>导致这样的原因：</p><p>​    首先<code>传值</code>和<code>传指针</code>。简单来说， 传指针可以修改内存中的数据， 而传值只能修改原值的<strong>副本</strong>。</p><p>如果我们去方法定义为</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">12</span>&#125;</code></pre><p>那么这这个方法的意图需要修改原值内存中的数据， 但是所以在传给<code>interface</code>的时候， 就需要传递给其地址， 因为只有知道地址， 才可以去其原值数据进行修改。</p><p>如果是进行传值， 那么不就只修改了副本， 而不修改原值</p><p>所以会进行报错</p><p><strong>go 会把指针进行隐式转换得到 value，但反过来则不行</strong>。</p><p>对应上例，修改成为</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> shirt iShirt = &amp;p</code></pre><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>在学习设计模式的时候， 对抽象工厂模式利用反射解耦映象深刻， 可惜c++没有反射(虽然可以利用map自己实现)， 只是看了一眼<code>C#</code>的用法。</p><p>对于反射， 认识十分片面，所以尝试在go中实现</p><p><code>adidas.go</code></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">type</span> adidas <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// adidas具体工厂</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *adidas)</span> <span class="hljs-title">makeShoe</span><span class="hljs-params">()</span> <span class="hljs-title">iShoe</span></span> &#123;<span class="hljs-keyword">return</span> &amp;shoe&#123;logo: <span class="hljs-string">&quot;adidas&quot;</span>,size: <span class="hljs-number">14</span>,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *adidas)</span> <span class="hljs-title">makeShirt</span><span class="hljs-params">()</span> <span class="hljs-title">iShirt</span></span> &#123;<span class="hljs-keyword">return</span> &amp;shirt&#123;logo: <span class="hljs-string">&quot;adidas&quot;</span>,size: <span class="hljs-number">14</span>,&#125;&#125;</code></pre><p><code>nike.go</code></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">type</span> nike <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *nike)</span> <span class="hljs-title">makeShoe</span><span class="hljs-params">()</span> <span class="hljs-title">iShoe</span></span> &#123;<span class="hljs-keyword">return</span> &amp;shoe&#123;logo: <span class="hljs-string">&quot;nike&quot;</span>,size: <span class="hljs-number">14</span>,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *nike)</span> <span class="hljs-title">makeShirt</span><span class="hljs-params">()</span> <span class="hljs-title">iShirt</span></span> &#123;<span class="hljs-keyword">return</span> &amp;shirt&#123;logo: <span class="hljs-string">&quot;nike&quot;</span>,size: <span class="hljs-number">14</span>,&#125;&#125;</code></pre><p><code>iShirt.go</code></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">type</span> iShirt <span class="hljs-keyword">interface</span> &#123;setLogo(logo <span class="hljs-keyword">string</span>)setSize(size <span class="hljs-keyword">int</span>)getLogo() <span class="hljs-keyword">string</span>getSize() <span class="hljs-keyword">int</span>&#125;<span class="hljs-keyword">type</span> shirt <span class="hljs-keyword">struct</span> &#123;logo <span class="hljs-keyword">string</span>size <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shirt)</span> <span class="hljs-title">setLogo</span><span class="hljs-params">(logo <span class="hljs-keyword">string</span>)</span></span> &#123;s.logo = logo&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shirt)</span> <span class="hljs-title">setSize</span><span class="hljs-params">(size <span class="hljs-keyword">int</span>)</span></span> &#123;s.size = size&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shirt)</span> <span class="hljs-title">getLogo</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> s.logo&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shirt)</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> s.size&#125;</code></pre><p><code>iShoe.go</code></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">type</span> iShoe <span class="hljs-keyword">interface</span> &#123;setLogo(logo <span class="hljs-keyword">string</span>)setSize(size <span class="hljs-keyword">int</span>)getLogo() <span class="hljs-keyword">string</span>getSize() <span class="hljs-keyword">int</span>&#125;<span class="hljs-keyword">type</span> shoe <span class="hljs-keyword">struct</span> &#123;logo <span class="hljs-keyword">string</span>size <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shoe)</span> <span class="hljs-title">setLogo</span><span class="hljs-params">(logo <span class="hljs-keyword">string</span>)</span></span> &#123;s.logo = logo&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shoe)</span> <span class="hljs-title">setSize</span><span class="hljs-params">(size <span class="hljs-keyword">int</span>)</span></span> &#123;s.size = size&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shoe)</span> <span class="hljs-title">getLogo</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> s.logo&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *shoe)</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> s.size&#125;</code></pre><p><code>iSportsFactory.go</code> 反射</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-comment">// 抽象工厂接口</span><span class="hljs-keyword">type</span> iSportsFactory <span class="hljs-keyword">interface</span> &#123;makeShoe() iShoemakeShirt() iShirt&#125;<span class="hljs-keyword">var</span> typeRegister = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]reflect.Type)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;typeRegister[<span class="hljs-string">&quot;adidas&quot;</span>] = reflect.TypeOf(adidas&#123;&#125;)typeRegister[<span class="hljs-string">&quot;nike&quot;</span>] = reflect.TypeOf(nike&#123;&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeInstance</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<span class="hljs-keyword">return</span> reflect.New(typeRegister[name]).Interface()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetSportsFactory</span><span class="hljs-params">(brand <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(iSportsFactory, error)</span></span> &#123;v := makeInstance(brand).(iSportsFactory)<span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span><span class="hljs-comment">// if brand == &quot;adidas&quot; &#123;</span><span class="hljs-comment">// return &amp;adidas&#123;&#125;, nil</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// if brand == &quot;nike&quot; &#123;</span><span class="hljs-comment">// return &amp;nike&#123;&#125;, nil</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return nil, fmt.Errorf(&quot;Wrong brand type passed&quot;)</span>&#125;</code></pre><p><code>main.go</code>客户端代码</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// adidasFactory, _ := getSportsFactroy(&quot;adidas&quot;)</span>nikeFactory, _ := GetSportsFactory(<span class="hljs-string">&quot;nike&quot;</span>)nikeShoe := nikeFactory.makeShoe()nikeShirt := nikeFactory.makeShirt()fmt.Println(<span class="hljs-string">&quot;nikeShirt: &quot;</span>, nikeShirt.getLogo(), nikeShirt.getSize())fmt.Println(<span class="hljs-string">&quot;nikeShoe: &quot;</span>, nikeShoe.getLogo(), nikeShoe.getSize())&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://i6448038.github.io/2018/10/01/Golang-interface/">https://i6448038.github.io/2018/10/01/Golang-interface/</a></p><p><a href="https://cloud.tencent.com/developer/article/1428644">https://cloud.tencent.com/developer/article/1428644</a></p><p><a href="https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/">https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/</a></p><p><a href="https://refactoringguru.cn/design-patterns/abstract-factory/go/example">https://refactoringguru.cn/design-patterns/abstract-factory/go/example</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-《Go专家编程》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github加速</title>
    <link href="/WennyAhhh.github.io/2021/03/08/github%E5%8A%A0%E9%80%9F/"/>
    <url>/WennyAhhh.github.io/2021/03/08/github%E5%8A%A0%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="github加速"><a href="#github加速" class="headerlink" title="github加速"></a>github加速</h1><h2 id="gitee"><a href="#gitee" class="headerlink" title="gitee"></a>gitee</h2><p>一般在github中的资源在<code>gitee</code>, 比如折磨我的<code>riscv-gnu-toolchain</code>项目， 在Gitee中有镜像项目</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210308141708173.png" alt="image-20210308141708173"></p><p>但是有些麻烦。</p><h2 id="代理链接-一般用这个方便"><a href="#代理链接-一般用这个方便" class="headerlink" title="代理链接(一般用这个方便)"></a>代理链接(一般用这个方便)</h2><p>域名：</p><p><a href="http://zygxsq.cn/github/">http://zygxsq.cn/github/</a></p><p>但是不用每次都要打开这个网页， 在需要git的代码中的<code>.com</code>修改成为<code>.zygxsq.cn</code>(可以记忆为资源共享社区)</p><p>速度对比(我这里的网络只有10M T_T,  校园网太贵了)</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210308140905319.png" alt="image-20210308140905319"></p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210308141155706.png" alt="image-20210308141155706"></p><h2 id="chrome插件"><a href="#chrome插件" class="headerlink" title="chrome插件"></a>chrome插件</h2><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210308142040178.png" alt="image-20210308142040178"></p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210308142030614.png" alt="image-20210308142030614"></p><p>其实和之前的代理链接一个原理</p><p>油猴里面也有<code>github</code>的加速脚本， 这里就不列出了。</p><h2 id="修改host"><a href="#修改host" class="headerlink" title="修改host"></a>修改host</h2><p><code>vim /etc/hosts</code></p><p>将 <a href="https://gitee.com/Mosiki/github/raw/master/github_hosts.txt">https://gitee.com/Mosiki/github/raw/master/github_hosts.txt</a> 这个网站中的信息添加到以上文件中。</p><p>上面的hosts是会更新的， 可以利用软件自动更新， 由于我大部分的使用情况是只使用<code>shell</code>， 很少使用GUI界面，也就懒得尝试了。</p><p>可以参考</p><p><a href="http://nullpointer.pw/github%E4%BB%A3%E7%A0%81clone%E5%8A%A0%E9%80%9F.html">http://nullpointer.pw/github%E4%BB%A3%E7%A0%81clone%E5%8A%A0%E9%80%9F.html</a></p><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>以上的方式都有一个致命的问题， 当一个项目中包含子模块的时候， 子模块没有添加代理链接呀， 比如<code>riscv-gnu-toolchain</code>,里面的<code>.git/config</code></p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210308213015884.png" alt="image-20210308213015884"></p><p>当然你可以不嫌累一个一个换过去， 但是你并不知道这个子模块里面会不会也有子模块(孙子模块？)，而riscv的这个项目就是这样的例子</p><p>但是对于我们这种良好网民， 有什么好的办法？</p><p>一般<code>1080</code>是<code>socks5</code>的端口，如果不是自己可以修改 (https好像没用？ 没有具体试过， 一般用http)</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置</span>git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080<span class="hljs-meta">#</span><span class="bash"> 取消</span>git config --global --unset http.proxygit config --global --unset https.proxynpm config delete proxy</code></pre><p>这样设置了之后， 会在<code>~/.gitconfig</code>中设置</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210308195501737.png" alt="image-20210308195501737"></p><p>由这样说， 那么就可以说明<code>https.proxy</code><del>没用</del>？</p><p>当然你由于是<code>socks5</code>, 所以也可以这样设置</p><pre><code class="hljs shell">git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27;git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27;</code></pre><p>这样， 127.0.0.1是本地环回地址， 也就是<code>git</code>下载的时候走的代理方式是1080端口。也就是本地代理。</p><p>有时候我们并不局限于<code>git</code>，所以可以设置</p><pre><code class="hljs shell">export ALL_PROXY=socks5://127.0.0.1:1080</code></pre><p>当然， 1080这个端口随着你的socket监听端口改变而改变。</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210308185136669.png" alt="image-20210308185136669"></p><p>使用了git 设置代理</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210308185307835.png" alt="image-20210308185307835"></p><p>但是这是本地代理， 并没有使用外部代理， 我一直没搞懂这个能加速的原理， 在阿里云的服务器上跑不尽如意。</p><h2 id="科学"><a href="#科学" class="headerlink" title="科学"></a>科学</h2><p>​    关于这个事，我简单说两句，至于我的身份，你明白就行，总而言之，这个事呢，现在就是这个情况，具体的呢，大家也都看得到，我因为这个身份上的问题，也得出来说那么几句，可能，你听的不是很明白，但是意思就是那么个意思，我的身份呢，不知道的你也不用去猜，这种事情见得多了，我只想说懂得都懂，不懂的我也不多解释，毕竟自己知道就好，细细品吧。你们也别来问我怎么了，利益牵扯太大，说了对你我都没好处，当不知道就行了，其余的我只能说这里面水很深，牵扯到很多东西。详细情况你们自己是很难找的，网上大部分已经删除干净了，所以我只能说懂得都懂。懂的人已经基本都获利上岸什么的了，不懂的人永远不懂，关键懂的人都是自己悟的，你也不知道谁是懂的人也没法请教，大家都藏着掖着生怕别人知道自己懂事，懂了就能收割不懂的，你甚至都不知道自己不懂。只是在有些时候，某些人对某些事情不懂装懂，还以为别人不懂。其实自己才是不懂的，别人懂的够多了，不仅懂，还懂的超越了这个范围，但是某些不懂的人让这个懂的人完全教不懂，所以不懂的人永远不懂，只能不懂装懂，别人说懂的都懂，只要点点头就行了，其实你懂的我也懂,谁让我们都懂呢,不懂的话也没必要装懂,毕竟里面牵扣扯到很多懂不了的事。这种事懂的人也没必要访出来,不懂的人看见又来问七问八,最后跟他说了他也不一定能懂,就算懂了以后也对他不好,毕竟懂的太多了不是好事。所以大家最好是不懂就不要去了解,懂太多不好 (知乎大佬那抄的)</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>瞎折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bomb lab</title>
    <link href="/WennyAhhh.github.io/2021/01/06/bomb%E5%AE%9E%E9%AA%8C/"/>
    <url>/WennyAhhh.github.io/2021/01/06/bomb%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="bomb-lab"><a href="#bomb-lab" class="headerlink" title="bomb lab"></a>bomb lab</h1><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><p>反编译</p><pre><code class="hljs bash">objdump -d bomb &gt; bomb.asm</code></pre><p>这样反编译就可以生成汇编文件，需要对照着看。下面试一些我之后会用到的<code>gdb</code>方式</p><pre><code class="hljs bash">1  (gdb) b（breakpoint）: 用法：b 函数名 ：对此函数进行中断 ；b 文件名：行号；   2  (gdb) run：启动程序，运行至程序的断点或者结束；   3  (gdb) l(list): 用法：l funcname，制定函数的源码   4  (gdb) n(next): 不进入函数，逐过程运行；   5  (gdb) c（<span class="hljs-built_in">continue</span>）：继续运行，跳至下一个断点；   6  (gdb) p（<span class="hljs-built_in">print</span>）：打印显示变量值,如果后面是地址，加上*，比如<span class="hljs-built_in">print</span>  *0x6030f0，寄存器<span class="hljs-built_in">print</span> <span class="hljs-variable">$rax</span>。后面跟的是一个变量而非地址   7  (gdb) <span class="hljs-built_in">set</span> variable=value, 为变量赋值；   8  (gdb) <span class="hljs-built_in">kill</span>：终止调试的程序；   9  (gdb) h（<span class="hljs-built_in">help</span>）：列出 gdb 详细命令帮助列表；   10 (gdb) clear filename.c:30：清除 30 行处的断点；   11 (gdb) info <span class="hljs-built_in">break</span>：显示断点信息；   12 (gdb) delete 断点编号：断点编号是 info <span class="hljs-built_in">break</span> 后显示出来的；   13 (gdb) q：退出；   14 (gdb) x(examine)：查看内存中的值等 // 详细内容在 gdb 中输入 <span class="hljs-built_in">help</span> x 查看。常用x/s <span class="hljs-variable">$rax</span>，打印rax地址中的字符串变量。x/d <span class="hljs-variable">$rax</span>，打印地址的十进制变量   15 (gdb) <span class="hljs-built_in">set</span> args xxx(file) 重定向输入文件，可以将答案存入这个文件中，然后在run之前使用此语句，就不需要再输入已知的正确答案。   16 (gdb) x/&lt;n/f/u&gt; &lt;addr&gt; 可以帮助打印数组。n是需要打印的个数;f是格式，z十六进制，d十进制;u是字节数，也就是一个数据块占的大小    默认是4个bytes。可以修改，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。addr是起始地址</code></pre><p>用到多的1,2,4,8,9,,12,15,16。</p><pre><code class="hljs bash">ax--r开头64位，eax--e开头32位</code></pre><blockquote><p>由于我之前是学习过王爽老师的《汇编语言》，是Intel风格的汇编，但是csapp中使用的是ATT风格的，顺序上有区别，需要注意</p></blockquote><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><pre><code class="hljs assembly">0000000000400ee0 &lt;phase_1&gt;:  400ee0:48 83 ec 08          sub    $0x8,%rsp  400ee4:be 00 24 40 00       mov    $0x402400,%esi  400ee9:e8 4a 04 00 00       callq  401338 &lt;strings_not_equal&gt;  400eee:85 c0                test   %eax,%eax  400ef0:74 05                je     400ef7 &lt;phase_1+0x17&gt;  400ef2:e8 43 05 00 00       callq  40143a &lt;explode_bomb&gt;  400ef7:48 83 c4 08          add    $0x8,%rsp  400efb:c3                   retq</code></pre><p>以上是<code>phase_1</code>的汇编代码</p><p>第一行：<code>sub    $0x8,%rsp</code> 准备栈帧（栈底到当前栈顶<code>rsp</code>的一段预留空间，每个具有局部变量的函数都将使用栈帧来存储自己的局部变量，这里大小是8个字节）。</p><p>第二行： <code>mov    $0x402400,%esi</code>，将一个立即数，也是一个字符串的地址传递给<code>%esi</code>，</p><p>第三行:    调用401338地址的<code>strings_not_equal</code>函数，看字面意思就是判断两个字符串是否相等，函数的部分汇编代码如下</p><pre><code class="hljs assembly">0000000000401338 &lt;strings_not_equal&gt;:  401338:41 54                push   %r12  40133a:55                   push   %rbp  40133b:53                   push   %rbx  40133c:48 89 fb             mov    %rdi,%rbx  40133f:48 89 f5             mov    %rsi,%rbp  .....  40139b:89 d0                mov    %edx,%eax  40139d:5b                   pop    %rbx  40139e:5d                   pop    %rbp  40139f:41 5c                pop    %r12  4013a1:c3                   retq</code></pre><p><code>push %12</code>是调用保存寄存器。</p><blockquote><p>R12 它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。</p></blockquote><p>现在这个函数<code>strings_not_equal</code>打点，然后输入字符串,此时还没有进入函数，但是<code>%rdi,%rsi</code>是传入的参数</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201231133451943.png" alt="image-20201231133451943"></p><p>由此可见，传入了<code>rbp rbx</code>两个寄存器，其中的值应该就是需要比较的值。</p><p>第四行： <code>test   %eax,%eax</code>,test命令对两个操作数按位与(AND)操作,设置符号标志位、零标志位和奇偶标志位。对于此来说，如果<code>%eax</code>为0.那么<code>ZF</code>标志位为1。</p><p>第五行： <code>je     400ef7 &lt;phase_1+0x17&gt;</code>跳转到<code>400ef7</code>地址，也就是避开了<code>explode_bomb</code>。当然，跳转的条件是<code>ZF</code>为1，也就是最近的操作的结果为<code>0</code></p><p>所以只需要查看<code>$0x402400,%esi，%rsi</code>这个内存地址和寄存器，并且输入相同的值。</p><p>所以在要求输入的时候输入<code>Border relations with Canada have never been better.</code>就可以通关啦.</p><pre><code class="hljs bash">Welcome to my fiendish little bomb. You have 6 phases with<span class="hljs-built_in">which</span> to blow yourself up. Have a nice day!Border relations with Canada have never been better.Phase 1 defused. How about the next one?</code></pre><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>刚看的时候很懵逼，其实是很多汇编代码不需要一步一步都明白，只需要理清脉络就行。或者说，有些代码你不需要知道是什么，但是可以通过断点，来判断寄存器或者内存地址里面有什么</p><pre><code class="hljs assembly">400efe:48 83 ec 28          sub    $0x28,%rsp400f02:48 89 e6             mov    %rsp,%rsi</code></pre><p><code>rsp</code>是栈底，由于栈是高地址到低地址，减去<code>0x28</code>表示有临时变量有40个字节大小，然后将<code>rsp</code>移到<code>rsi</code>当中去，就可以保存栈顶</p><pre><code class="hljs assembly">400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;400f0a:83 3c 24 01          cmpl   $0x1,(%rsp)400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt;</code></pre><p>看字面意思是读取六个数字。然后对<code>rsp</code>中的值与<code>0x1</code>对比，如果相等就跳转(避免调用bomb函数)。由于<code>rsp</code>被作为栈顶指针，所以我们有理由判断，这个比较是要求输入的第一个数字是<code>1</code>。然后我们可以进行断点检测。断点断在<code>0x400f0a</code>这个点上，因为此时<code>read</code>调用已经完成。我们可以通过<code>rsp</code>寄存器，并进行偏移来查看值。每个数字的字节大小是4。这里是否需要注意输入顺序？</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201231232131468.png" alt="image-20201231232131468"></p><pre><code class="hljs assembly">400f30:48 8d 5c 24 04       lea    0x4(%rsp),%rbx400f35:48 8d 6c 24 18       lea    0x18(%rsp),%rbp400f3a:eb db                jmp    400f17 &lt;phase_2+0x1b&gt;   # 400F17</code></pre><p>这里是上一步跳转过来的地址，初始化。<code>0x4(%rsp)</code>这个地址是array[1]的地址，也就是第二个数字。<code>0x18(%rsp)</code>这个地址是array[6]的地址，也就是最后一个地址.</p><p>综上，<code>rbx</code>是第一个数,<code>rbp</code>是第六个数后面的地址(第七个数，但是没有输入，相当于C++迭代器的<code>end()</code>)。</p><pre><code class="hljs assembly">400f17:8b 43 fc             mov    -0x4(%rbx),%eax400f1a:01 c0                add    %eax,%eax400f1c:39 03                cmp    %eax,(%rbx)400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt;   # 400f25400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;400f25:48 83 c3 04          add    $0x4,%rbx400f29:48 39 eb             cmp    %rbp,%rbx400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;   # 400F17400f2e:eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;   # 400F3C</code></pre><p>观察这段代码，就会发现其实这个是一个循环。对于第一个循环。<code>eax</code>的值被设置为<code>rbx</code>的下一个地址的值，也就是第一个数。</p><p>add将<code>eax</code>乘二,然后对比。如果不相等，就会跳转到<code>bomb</code>。所以给出一个限制条件 <strong>后面的数字是前面数字的两倍</strong></p><p>一直到循环结束，也就是<code>rbp == rbx</code>，也就是数组到头了。那么就跳出循环。第二题结束。</p><p>所以这关的密码是</p><p><code>1 2 4 8 16 32</code></p><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><pre><code class="hljs assembly">400f43:48 83 ec 18          sub    $0x18,%rsp400f47:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx400f4c:48 8d 54 24 08       lea    0x8(%rsp),%rdx400f51:be cf 25 40 00       mov    $0x4025cf,%esi400f56:b8 00 00 00 00       mov    $0x0,%eax400f5b:e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</code></pre><p>最后一行是调用<code>scanf</code>函数，所以这应该是准备输入<code>scanf</code>的前置工作。前三个没啥好说的，就是一个栈的准备工作。在第四行，多了一个地址<code>$0x4025cf</code>,这个地址很明显藏了东西，用<code>gdb</code>尝试看一下里有什么。在<code>400f5b</code>断点</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210101212107149.png" alt="image-20210101212107149"></p><p>我尝试了整数和字符串形式，很显然字符串的那个我们太熟悉了，这不就是<code>scanf</code>的输入两个整数嘛。由此可得，输入的是两个整数</p><pre><code class="hljs assembly">400f60:83 f8 01             cmp    $0x1,%eax400f63:7f 05                jg     400f6a &lt;phase_3+0x27&gt;400f65:e8 d0 04 00 00       callq  40143a &lt;explode_bomb&gt;</code></pre><p>发现有个<code>cmp</code>对比，也就是看看<code>rax</code>是不是<code>0x1</code>，如果是那就会<code>bomb</code>。断点调试看看<code>rax</code>是什么</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210101214416983.png" alt="image-20210101214416983"></p><p>然后在往上看，在调用<code>scanf</code>前面就重置为<code>0x0</code>,而调用之后就变为了2，说明这是<code>scanf</code>所改变的,联系到之前<code>%d %d</code>，猜测会不会是输入整数的个数。那么我输入一个整数试试。</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210101214527477.png" alt="image-20210101214527477"></p><p>果然。是一个。然后想想，scanf如果只是<code>%d %d</code>只会输入两个，如果是三个及以上那么也不会输入以后的，如果是0个那么就不会输入。</p><pre><code class="hljs assembly">400f6a:83 7c 24 08 07       cmpl   $0x7,0x8(%rsp)400f6f:77 3c                ja     400fad &lt;phase_3+0x6a&gt;400f71:8b 44 24 08          mov    0x8(%rsp),%eax400f75:ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8)</code></pre><p>看到<code>0x8(%rsp)</code>,<code>%rsp</code>寄存器是栈顶指针，根据第二题，就可以推断出这个是输入的字符。我们可以断点查看一下这两个</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210101215629856.png" alt="image-20210101215629856"></p><p>果然，这两个地址就是输入的数字，然后，这里的<code>rsp+0x8</code>就是输入的第一个数字，与<code>0x7</code>比较，然后看跳转命令<code>ja</code>，表示<strong>无符号整数</strong>大于就跳转(跳到<code>bomb</code>)，在<code>ATT</code>中表示<code>rsp+0x8 &gt; 0x7</code>,所以这里的限制条件就是第一个数字在<code>0~7</code>之间。</p><p>这段代码最后一行困惑了我很久，原因在于我的断点调试。首先我肯定 <code>0x402470</code>当中储存的是地址，然后</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210101220749973.png" alt="image-20210101220749973"></p><p>这个地址就是这段代码的后续第一个地址，也就是<code>rax</code>为0的情况。计算的结果我<strong>一开始</strong>认为是<code>0x400f7c+%rax*8</code>，然后跳转到这个地址。但是我发现除了0，没有第一个地址是符合的。于是就感到困惑。</p><p>后来在网上查了资料，猛然发现，解引用的优先级要低一些，也就是<strong>正确</strong>的操作顺序是<code>*(0x402470+%rax*8)</code>，这才恍然大悟：在网课上，老师其实已经提到过，对于<code>switch</code>来说，由于查找的东西都是已经固定的，所以对于相对连续的值就不会使用<code>if-else</code>，那是采用哈希表的方式，将值储存在一个数组当中。数组中的值当然是需要跳转的地址。对于这题来说<code>0x402470</code>就是数组的起始地址。</p><p>那么就看看这个长度为8的数组里面都是什么</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210101221744716.png" alt="image-20210101221744716"></p><pre><code class="hljs assembly">400f7c:b8 cf 00 00 00       mov    $0xcf,%eax400f81:eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;400f83:b8 c3 02 00 00       mov    $0x2c3,%eax400f88:eb 34                jmp    400fbe &lt;phase_3+0x7b&gt;400f8a:b8 00 01 00 00       mov    $0x100,%eax400f8f:eb 2d                jmp    400fbe &lt;phase_3+0x7b&gt;400f91:b8 85 01 00 00       mov    $0x185,%eax400f96:eb 26                jmp    400fbe &lt;phase_3+0x7b&gt;400f98:b8 ce 00 00 00       mov    $0xce,%eax400f9d:eb 1f                jmp    400fbe &lt;phase_3+0x7b&gt;400f9f:b8 aa 02 00 00       mov    $0x2aa,%eax400fa4:eb 18                jmp    400fbe &lt;phase_3+0x7b&gt;400fa6:b8 47 01 00 00       mov    $0x147,%eax400fab:eb 11                jmp    400fbe &lt;phase_3+0x7b&gt;400fad:e8 88 04 00 00       callq  40143a &lt;explode_bomb&gt;400fb2:b8 00 00 00 00       mov    $0x0,%eax400fb7:eb 05                jmp    400fbe &lt;phase_3+0x7b&gt;400fb9:b8 37 01 00 00       mov    $0x137,%eax</code></pre><p>可以一一对应，也就是这题有8种选择。跳转过去，每个都有对应的值赋值给<code>eax</code></p><pre><code class="hljs assembly">400fbe:3b 44 24 0c          cmp    0xc(%rsp),%eax400fc2:74 05                je     400fc9 &lt;phase_3+0x86&gt;400fc4:e8 71 04 00 00       callq  40143a &lt;explode_bomb&gt;400fc9:48 83 c4 18          add    $0x18,%rsp</code></pre><p>第一行，<code>$rsp+0xc</code>对应的值是第二个输入的值，<code>%eax</code>,但是<code>eax</code>的值是由第一个所决定的，换句话说，第一个值确定了(0~7)，那么第二个值就也确定了.</p><p>这里我选择<code>0 207</code>作为答案。</p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>有了前几道题目的思考，这道题目意外的简单。 </p><pre><code class="hljs assembly">401010:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx401015:48 8d 54 24 08       lea    0x8(%rsp),%rdx40101a:be cf 25 40 00       mov    $0x4025cf,%esi40101f:b8 00 00 00 00       mov    $0x0,%eax401024:e8 c7 fb ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;401029:83 f8 02             cmp    $0x2,%eax40102c:75 07                jne    401035 &lt;phase_4+0x29&gt;40102e:83 7c 24 08 0e       cmpl   $0xe,0x8(%rsp)401033:76 05                jbe    40103a &lt;phase_4+0x2e&gt;401035:e8 00 04 00 00       callq  40143a &lt;explode_bomb&gt;</code></pre><p>老面孔了，可以gdb调试看看<code>esi</code>值，我这边就不展示，因为这个内存地址都和第三题一模一样，里面的内容是<code>%d %d</code>。</p><p>也就是输入两个数字吧。后面规定了长度为2，<code>jbe</code>是无符号小于等于的意思，这边是需要跳转过去的，也就是说，输入的数字取值范围在**(0~14)**</p><pre><code class="hljs assembly">40103a:ba 0e 00 00 00       mov    $0xe,%edx40103f:be 00 00 00 00       mov    $0x0,%esi401044:8b 7c 24 08          mov    0x8(%rsp),%edi401048:e8 81 ff ff ff       callq  400fce &lt;func4&gt;40104d:85 c0                test   %eax,%eax</code></pre><p>前三行明显的传参行为，然后调用<code>func4</code>，最后<code>test</code>。由于在调用函数前已经重置为<code>0</code>,所以<code>eax</code>就是返回值，用于后续的比较</p><p>此时<code>edx = 14 esi = 0 edi = x</code>，其中x表示第一个输入参数，y表示第二个输入参数</p><p>查看<code>func</code></p><pre><code class="hljs assembly">400fd2:89 d0                mov    %edx,%eax400fd4:29 f0                sub    %esi,%eax400fd6:89 c1                mov    %eax,%ecx400fd8:c1 e9 1f             shr    $0x1f,%ecx400fdb:01 c8                add    %ecx,%eax400fdd:d1 f8                sar    %eax400fdf:8d 0c 30             lea    (%rax,%rsi,1),%ecx</code></pre><p>一些前置操作而已，这是第一次调用</p><table><thead><tr><th>edx</th><th>14</th></tr></thead><tbody><tr><td>eax</td><td>14 -&gt; 14 -&gt; 7</td></tr><tr><td>edi</td><td>x</td></tr><tr><td>esi</td><td>0</td></tr><tr><td>ecx</td><td>7</td></tr></tbody></table><pre><code class="hljs assembly">400fe2:39 f9                cmp    %edi,%ecx400fe4:7e 0c                jle    400ff2 &lt;func4+0x24&gt;</code></pre><p><code>jle</code>是有符号的小于等于。也就是说如果输入的值是<code>x &gt;= ecx</code>就会跳转。查看跳转之后的命令：</p><pre><code class="hljs assembly">400ff2:b8 00 00 00 00       mov    $0x0,%eax400ff7:39 f9                cmp    %edi,%ecx400ff9:7d 0c                jge    401007 &lt;func4+0x39&gt;</code></pre><p>这段代码很奇怪一点在于，首先吧<code>eax</code>置为0，然后依然对于上面已经对比过的，<code>jge</code>是大于等于就跳转并函数返回。那么对于<code>&gt;= 7</code>以及<code>&lt;= 7</code>，第一个参数是7就可以直接返回，并且<code>eax</code>为0。</p><pre><code class="hljs assembly"># phase_440104d:85 c0                test   %eax,%eax40104f:75 07                jne    401058 &lt;phase_4+0x4c&gt;401051:83 7c 24 0c 00       cmpl   $0x0,0xc(%rsp)401056:74 05                je     40105d &lt;phase_4+0x51&gt;401058:e8 dd 03 00 00       callq  40143a &lt;explode_bomb&gt;40105d:48 83 c4 18          add    $0x18,%rsp</code></pre><p>函数返回之后，用<code>test</code>对比，由于<code>eax</code>是0，所以<code>jne</code>的不等于是无法通过的，也避免了<code>boom</code>，然后第二参数y与0对比，相等就跳转，然后结束。所以如果需要答案的话<code>7 0 </code>就可以直接正确了。</p><p>但是！和剧情游戏一样，没有跑完全部支线是不完美的，由于第一个参数是一个<code>&lt;= 14</code>的数字，在<code>func4</code>中需要判断是否<code>&gt;= 7</code>，并且在<code>func4</code>代码中，可以发现:</p><pre><code class="hljs assembly">400fe6:8d 51 ff             lea    -0x1(%rcx),%edx400fe9:e8 e0 ff ff ff       callq  400fce &lt;func4&gt;400fee:01 c0                add    %eax,%eax</code></pre><p>第二行，就是一个<strong>递归</strong>！并且第一行改变了<code>edx</code>，会导致递归后的寄存器的值和第一次进入函数不一样。</p><p>假设输入的数字<code>&lt;7</code>，那么就进入这段代码，<code>edx = 6</code>,第二次调用</p><table><thead><tr><th>edx</th><th>6</th></tr></thead><tbody><tr><td>eax</td><td>3</td></tr><tr><td>edi</td><td>x</td></tr><tr><td>esi</td><td>0</td></tr><tr><td>ecx</td><td>3</td></tr></tbody></table><p>发现了么？-1并且除二，这就是刻在DNA里面的<strong>二分</strong>啊！判断条件<code>%edi,%ecx</code> ,<code>x &gt;= 3</code>。</p><p>如果抓到二分这个条件的话，其实后面的东西就迎刃而解了。可以自己分析出来的是<code>esi是左边界，edx是右边界 ecx是mid</code></p><p>但是这个二分有些奇怪，平常的二分是用来搜索的，这个二分就是用来刁难的。观察</p><pre><code class="hljs assembly"># func4400fe2:39 f9                cmp    %edi,%ecx400fe4:7e 0c                jle    400ff2 &lt;func4+0x24&gt;400fe6:8d 51 ff             lea    -0x1(%rcx),%edx400fe9:e8 e0 ff ff ff       callq  400fce &lt;func4&gt;400fee:01 c0                add    %eax,%eax400ff0:eb 15                jmp    401007 &lt;func4+0x39&gt;400ff2:b8 00 00 00 00       mov    $0x0,%eax400ff7:39 f9                cmp    %edi,%ecx400ff9:7d 0c                jge    401007 &lt;func4+0x39&gt;400ffb:8d 71 01             lea    0x1(%rcx),%esi400ffe:e8 cb ff ff ff       callq  400fce &lt;func4&gt;401003:8d 44 00 01          lea    0x1(%rax,%rax,1),%eax</code></pre><p>以上代码转化成部分C语言就是</p><pre><code class="hljs c"><span class="hljs-keyword">if</span>(edi &lt; ecx)&#123;    edx = rcx <span class="hljs-number">-1</span> ;  <span class="hljs-comment">//right = mid - 1</span>    func4(edx, esi, edi);<span class="hljs-comment">//左边界，右边界，值</span>    eax += eax;&#125;<span class="hljs-keyword">else</span> &#123;    eax = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(edi &lt;= ecx)&#123; <span class="hljs-comment">//其实这里写成 == 也是一样的</span>        <span class="hljs-keyword">return</span> ;    &#125;    esi = rcx + <span class="hljs-number">1</span>;    func4(edx, esi, edi);    eax = eax + eax + <span class="hljs-number">1</span>;&#125;</code></pre><p>而观察<code>phase_4</code>的代码，会发现最后一定要求<code>eax</code>的值为0。虽然只要在0~14当中，最后的<code>eax</code>值一定会是0,但是由于<code>eax = eax + eax + 1;</code>这段代码的存在，导致在二分的过程中，不可以运行这段代码，否则<code>bomb！</code>。换句话说，<strong>每次二分产生的<code>mid</code>都必须大于等于x</strong></p><p>所以，x的值就是<code>7 3 1 0</code>中任意一个。</p><p>对于第二个参数，我不明白是用来干嘛的，除了第二行放入<code>rcx</code>（在代码中没有什么用）和倒数第五行要求是<code>0</code>，就没有戏份了。所以固定死了第二参数为<code>0</code></p><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>这关也比较常规了</p><pre><code class="hljs assembly">401062:53                   push   %rbx401063:48 83 ec 20          sub    $0x20,%rsp401067:48 89 fb             mov    %rdi,%rbx40106a:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax401071:00 00 401073:48 89 44 24 18       mov    %rax,0x18(%rsp)401078:31 c0                xor    %eax,%eax40107a:e8 9c 02 00 00       callq  40131b &lt;string_length&gt;40107f:83 f8 06             cmp    $0x6,%eax401082:74 4e                je     4010d2 &lt;phase_5+0x70&gt;</code></pre><p>这里我们只需要观察到这个<code>string_length</code>就可以了。更具前面几题的经验，很显然，<code>eax</code>里面存放的是输入字符串的长度，也就是说需要输入六个字符。然后跳转</p><pre><code class="hljs assembly">4010d2:b8 00 00 00 00       mov    $0x0,%eax4010d7:eb b2                jmp    40108b &lt;phase_5+0x29&gt;</code></pre><p>置零而已</p><p>接下来的代码不观察后续代码简直不知所云。但是很显然的是这是一个循环，通过<code>eax</code>,每次循环便加一，直到为6就跳转。也就是循环了6次</p><pre><code class="hljs assembly">40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx40108f:88 0c 24             mov    %cl,(%rsp)401092:48 8b 14 24          mov    (%rsp),%rdx401096:83 e2 0f             and    $0xf,%edx401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)4010a4:48 83 c0 01          add    $0x1,%rax4010a8:48 83 f8 06          cmp    $0x6,%rax4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;</code></pre><p>先放一下，然后观察后续的代码</p><pre><code class="hljs assembly">4010ae:c6 44 24 16 00       movb   $0x0,0x16(%rsp)4010b3:be 5e 24 40 00       mov    $0x40245e,%esi4010b8:48 8d 7c 24 10       lea    0x10(%rsp),%rdi4010bd:e8 76 02 00 00       callq  401338 &lt;strings_not_equal&gt;4010c2:85 c0                test   %eax,%eax4010c4:74 13                je     4010d9 &lt;phase_5+0x77&gt;</code></pre><p>这和第一题差不多，那么应该<code>rsi</code>是代码提供的字符串，而<code>rdi</code>是我们输入的。gdb调试一下</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210103103627130.png" alt="image-20210103103627130"></p><p><code>rsi</code>确实是我们猜想的，系统给的，但是<code>rdi</code>却不是我们输入的。结合我们之前暂时跳过的那一段代码，我们可以猜测，那段代码对我们输入的字符进行了<strong>变换</strong></p><pre><code class="hljs assembly">40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx40108f:88 0c 24             mov    %cl,(%rsp)401092:48 8b 14 24          mov    (%rsp),%rdx401096:83 e2 0f             and    $0xf,%edx401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)4010a4:48 83 c0 01          add    $0x1,%rax4010a8:48 83 f8 06          cmp    $0x6,%rax4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;</code></pre><p>在第一个循环中，先对第一行打点</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210103104107232.png" alt="image-20210103104107232"></p><p>第二行</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210103104316442.png" alt="image-20210103104316442"></p><p>显然，这两行代码的作用就是依次取出字符，因为一个地址对应一个字节<code>q</code>对应的ASCII是<code>113</code></p><p>之后的两行代码无非是<code>mov</code>，可以打点看看<code>%rdx</code>是什么</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210103114113662.png" alt="image-20210103114113662"></p><p>有些不明显，转化成二进制会发现，最后的8位就是<code>113</code></p><p>后面，使用<code>0xf</code>也就是<code>1111</code>进行与操作，结果就是最后四位，对于<code>113</code>，结果就是<code>1</code></p><pre><code class="hljs rassembly">401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)</code></pre><p>第一行是关键，这里很明显，这是个数组。起始地址为<code>0x4024b0</code>，<code>rdx</code>就是下标，也就是，我们输入的字符的<strong>二进制最后四位</strong>。可以查看这个数组都藏掖了什么</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210103114602792.png" alt="image-20210103114602792"></p><p>哈，那么问题就迎刃而解了。只需要倒推就可以了。</p><p>理一下思路，我们需要的结果是<code>flyers</code>，但是我们不能直接输入这个字符串，而是先计算这个字符串每个字符的ASCII码，然后根据上表找下标，下标值就是后四位。</p><p>前三位可以是固定的<code>110</code>,但是也不一定，只要在<code>ASCII</code>表中找到后四位满足条件就行</p><p>例如<code>f</code>,<code>ASCII</code>对应的是<code>102</code>,查表可得下标为<code>9</code>,对应的<code>ASCII</code>为<code>1001</code>,可以在前面加任意组合，只要在<code>ASCII</code>表中就行，这里选用<code>110</code>,也就是<code>110 1001</code>，对应105，字符为<code>i</code></p><p>以此类推，答案为<code>ionefg</code>。当然结果可以有很多个。</p><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>这道题目稍微复杂一些</p><pre><code class="hljs assembly">4010fc:48 83 ec 50          sub    $0x50,%rsp401100:49 89 e5             mov    %rsp,%r13401103:48 89 e6             mov    %rsp,%rsi401106:e8 51 03 00 00       callq  40145c &lt;read_six_numbers&gt;40110b:49 89 e6             mov    %rsp,%r1440110e:41 bc 00 00 00 00    mov    $0x0,%r12d401114:4c 89 ed             mov    %r13,%rbp401117:41 8b 45 00          mov    0x0(%r13),%eax40111b:83 e8 01             sub    $0x1,%eax40111e:83 f8 05             cmp    $0x5,%eax401121:76 05                jbe    401128 &lt;phase_6+0x34&gt;401123:e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;401128:41 83 c4 01          add    $0x1,%r12d40112c:41 83 fc 06          cmp    $0x6,%r12d401130:74 21                je     401153 &lt;phase_6+0x5f&gt;</code></pre><p>第二行，<code>rsp</code>是栈帧的首部地址，将首地址放在了<code>r13</code>，以及<code>rsi</code>。<code>rsi</code>是传递的第二个参数</p><p>然后调用<code>read_six_number</code>即输入六个数字。假如输入<code>1 2 3 4 5 6</code>，那么可以查看<code>rsp</code>的地址</p><p>​    <img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105134440166.png" alt="image-20210105134440166"></p><p>通过<code>%r13</code>的首部地址，传给<code>rax</code>，减<code>1</code>，然后与<code>5</code>比较，<code>jbe</code>也就是<code>0x5 &gt;= %eax </code>,也就是说，</p><p><strong>输入的数字一定是在<code>1~6</code>之间的</strong>。</p><p><code>%r12</code>其实就是一个计数器，从被初始化为0，然后+1直到为6。这一点可以在后续的代码中表示出来</p><pre><code class="hljs assembly">401132:44 89 e3             mov    %r12d,%ebx401135:48 63 c3             movslq %ebx,%rax401138:8b 04 84             mov    (%rsp,%rax,4),%eax40113b:39 45 00             cmp    %eax,0x0(%rbp)40113e:75 05                jne    401145 &lt;phase_6+0x51&gt;401140:e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;401145:83 c3 01             add    $0x1,%ebx401148:83 fb 05             cmp    $0x5,%ebx40114b:7e e8                jle    401135 &lt;phase_6+0x41&gt;40114d:49 83 c5 04          add    $0x4,%r13401151:eb c1                jmp    401114 &lt;phase_6+0x20&gt;</code></pre><p>首先将<code>r12</code>的值交给<code>ebx</code>,然后交给<code>rax</code>,然后使用mov指令，将<code>rax</code>的值设置为第二个输入数字，也就是2。因为后面出现了<code>cmp</code>，我们可以看看这些寄存器都是些什么</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105154548771.png" alt="image-20210105154548771"><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105154600188.png" alt="image-20210105154600188"></p><p>结合代码，很明显就看出来，这是一前一后的关系，如果等于，那么就会<code>bomb</code>。</p><p>接下来，可以看出<code>ebx</code>也是一个计数器，且初始值也是<code>r12</code>，并且进行循环，所以可以粗略的写成如下代码</p><pre><code class="hljs c"><span class="hljs-keyword">for</span>(r12 = <span class="hljs-number">0</span>; r12 &lt; <span class="hljs-number">5</span>; r12++)&#123;<span class="hljs-comment">//在上述汇编代码中，如果r12加1为6，那么就不进行接下来内部循环了。</span>    <span class="hljs-keyword">for</span>(edx = r12 + <span class="hljs-number">1</span>; edx &lt;= <span class="hljs-number">5</span>; edx++)&#123;        <span class="hljs-keyword">if</span>(rsp[r12] == rsp[edx])&#123;            bomb!!!        &#125;    &#125;&#125;</code></pre><p><strong>每个数字都是不重复的</strong></p><p>后续代码</p><pre><code class="hljs assembly">401153:48 8d 74 24 18       lea    0x18(%rsp),%rsi401158:4c 89 f0             mov    %r14,%rax40115b:b9 07 00 00 00       mov    $0x7,%ecx401160:89 ca                mov    %ecx,%edx401162:2b 10                sub    (%rax),%edx    # 1401164:89 10                mov    %edx,(%rax)401166:48 83 c0 04          add    $0x4,%rax# 240116a:48 39 f0             cmp    %rsi,%rax40116d:75 f1                jne    401160 &lt;phase_6+0x6c&gt;</code></pre><p>在此中，<code>rsi</code>中储存了<code>%rsp+0x18</code>的地址，由于一个整数的字节大小是4，并且，<code>0x18</code>的十进制是24,所以这个<code>rsi</code>中是数据最后的地址</p><p><code>r14</code>根据前面的内容，是<code>rsp</code>的栈帧，之后将其赋值给<code>rax</code>，到#1，其实是<code>7-(%rax)</code></p><p>#2这段是将<code>rax</code>为选择下一个数据，然后对比是不是最后一个,如果不是就继续循环。</p><p><strong>修改每个输入的数据，修改为<code>7 - rsp[0~5]</code></strong></p><p>例如<code>1 2 3 4 5 6</code>就会被转化为<code>6 5 4 3 2 1</code></p><pre><code class="hljs assembly">40116f:be 00 00 00 00       mov    $0x0,%esi 401174:eb 21                jmp    401197 &lt;phase_6+0xa3&gt;# 1 401176:48 8b 52 08          mov    0x8(%rdx),%rdx 40117a:83 c0 01             add    $0x1,%eax 40117d:39 c8                cmp    %ecx,%eax 40117f:75 f5                jne    401176 &lt;phase_6+0x82&gt;# 2 401181:eb 05                jmp    401188 &lt;phase_6+0x94&gt;# 3 401183:ba d0 32 60 00       mov    $0x6032d0,%edx 401188:48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2) 40118d:48 83 c6 04          add    $0x4,%rsi 401191:48 83 fe 18          cmp    $0x18,%rsi 401195:74 14                je     4011ab &lt;phase_6+0xb7&gt;# 4 401197:8b 0c 34             mov    (%rsp,%rsi,1),%ecx 40119a:83 f9 01             cmp    $0x1,%ecx 40119d:7e e4                jle    401183 &lt;phase_6+0x8f&gt;# 5 40119f:b8 01 00 00 00       mov    $0x1,%eax 4011a4:ba d0 32 60 00       mov    $0x6032d0,%edx 4011a9:eb cb                jmp    401176 &lt;phase_6+0x82&gt;# 6</code></pre><p>这段代码比较复杂，跳转语句太多了，所以慢慢来~</p><p>#1前先重置<code>esi</code>，然后跳转直到执行#5。很明显的是 mov语句使<code>%ecx</code>的值为第一个输入值,然后查看是否小于等于<code>1</code>，由于不可能是负数，所以这里只可能是1的情况下不跳转。</p><p>因为 大多数都是不为1，如果不跳过去直到执行#6,。这里出现了一个储存地址<code>$0x6032d0</code>，来看看这个是什么</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105163324319.png" alt="image-20210105163324319"></p><p>一个暂时还不知道干嘛的整数。然后接下来观察跳转过去的代码，发现了我们熟悉的<code>add</code>然后<code>cmp</code>再<code>jne/je</code>格式的跳转，没问题，这一定是一个for循环。</p><p>至于循环的初始值是<code>rax</code>已经在刚开始的时候设置成为<code>0x1</code>，<code>ecx</code>就是我们输入的数字x的<code>7-x</code>。</p><p>于是我们就豁然开朗了起来，这个<code>0x6032d0</code>是一个数组的首地址，我们输入，然后通过<code>7 - x</code>处理之后的数字是下标(为什么不用随机寻址一步到位？)</p><p>于是可以看看这个数组里面是什么东西，断点查看一下</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105200922012.png" alt="image-20210105200922012"></p><p>结果非常amazing啊，其实这不是一个数组，而是一个<strong>链表</strong>。这也就是为什么不用随机寻址的原因。</p><p>然后将其放在<code>0x20(%rsp, %rsi, 2)</code>这个地址里面，对于<code>rsi</code>为<code>0x0</code>的情况，就会将这个值放在<code>%rsp+0x20</code>这个位置。运行一下，理论上这个值应该是链表中第六个的值。</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105201229432.png" alt="image-20210105201229432"></p><p>果然如此（不是我就不会写上去了）</p><p><code>rsi</code>为初始大小，然后每次加上<code>0x4</code>大小，上限是<code>0x18</code>，也就是6个<code>int</code>类型的大小。对于<code>rdx</code>，其实就是链表的地址，每次<code>+0x8</code>，其实就是找下一个地址，很巧的是这个的地址十分规整，是连续的地址。</p><p><strong>由此此段代码会在<code>rsp+0x20</code>的基础上加上六个链表中带来的数字，且每个所占大小为8个字节</strong></p><pre><code class="hljs assembly">4011ab:48 8b 5c 24 20       mov    0x20(%rsp),%rbx4011b0:48 8d 44 24 28       lea    0x28(%rsp),%rax4011b5:48 8d 74 24 50       lea    0x50(%rsp),%rsi4011ba:48 89 d9             mov    %rbx,%rcx</code></pre><p>浅显的代码，<code>rsi</code>放上限，<code>rbx</code>放第一参数，<code>rax</code>放第二个参数,<code>rcx</code>放第一个参数，都是地址。我们可以查看<code>rsp</code>的值</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105204618502.png" alt="image-20210105204618502"></p><p>一个块占8个字节，前四个字节是链表地址，里面有值，后面是没有设置的0。</p><pre><code class="hljs assembly">4011bd:48 8b 10             mov    (%rax),%rdx4011c0:48 89 51 08          mov    %rdx,0x8(%rcx)4011c4:48 83 c0 08          add    $0x8,%rax4011c8:48 39 f0             cmp    %rsi,%rax4011cb:74 05                je     4011d2 &lt;phase_6+0xde&gt;4011cd:48 89 d1             mov    %rdx,%rcx4011d0:eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;</code></pre><p>这段代码我不知道是来干嘛的，前面的参数加一个偏移量<code>0x8</code>然后给后面的赋值？这不是没有改变什么？除了<code>rax</code> </p><pre><code class="hljs assembly">4011da:bd 05 00 00 00       mov    $0x5,%ebp4011df:48 8b 43 08          mov    0x8(%rbx),%rax4011e3:8b 00                mov    (%rax),%eax4011e5:39 03                cmp    %eax,(%rbx)4011e7:7d 05                jge    4011ee &lt;phase_6+0xfa&gt;4011e9:e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;4011ee:48 8b 5b 08          mov    0x8(%rbx),%rbx4011f2:83 ed 01             sub    $0x1,%ebp4011f5:75 e8                jne    4011df &lt;phase_6+0xeb&gt;</code></pre><p>最后一段代码了，很简单操作，观察<code>cmp</code>，想不触发必须<code>eax &lt;= rbx</code>，<code>eax</code>是后一个参数，<code>rbx</code>是前一个参数,然后循环5次</p><p>简而言之，<strong>降序排列</strong></p><p>根据：</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105205636072.png" alt="image-20210105205636072"></p><p>所以顺序为<code>3 4 5 6 1 2</code>，由于<code>7 - x</code>，所以答案是：</p><p><code>4 3 2 1 6 5</code></p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋~"></a>彩蛋~</h2><p>非常amazing，第一次见到实验题还有彩蛋的。</p><p>（我本来不知道还有彩蛋，做完翻看答案的时候才发现有这个，而且还藏在C文件中）</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105210630417.png" alt="image-20210105210630417"></p><p>注释告诉你其实还有彩蛋</p><p>我们可以查看<code>phase_defused</code>函数,截取了一段代码</p><pre><code class="hljs assembly">4015f0:be 19 26 40 00       mov    $0x402619,%esi4015f5:bf 70 38 60 00       mov    $0x603870,%edi4015fa:e8 f1 f5 ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;4015ff:83 f8 03             cmp    $0x3,%eax401602:75 31                jne    401635 &lt;phase_defused+0x71&gt;401604:be 22 26 40 00       mov    $0x402622,%esi401609:48 8d 7c 24 10       lea    0x10(%rsp),%rdi40160e:e8 25 fd ff ff       callq  401338 &lt;strings_not_equal&gt;401613:85 c0                test   %eax,%eax401615:75 1e                jne    401635 &lt;phase_defused+0x71&gt;......40162b:b8 00 00 00 00       mov    $0x0,%eax401630:e8 0d fc ff ff       callq  401242 &lt;secret_phase&gt;</code></pre><p>可以打点查看这两个<code>0x402619</code>和<code>0x603870</code></p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105211159452.png" alt="image-20210105211159452"></p><p>这个<code>3 0</code>是我们在第四关输入的答案，前面的是<code>scanf</code>输入的字符串，后面跟了一个<code>%s</code>，然后更具后面返回的<code>eax</code>可以得出，输入两个和三个是有区别的，两个就直接跳过彩蛋，但是三个就可以找到这个隐藏的彩蛋！</p><p>后面有个<code>strings_not_equal</code>，很明显这个彩蛋也要有特殊的字符，也就是藏在了<code>0x402622</code>当中！</p><p>可以gdb查看一下</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105211506424.png" alt="image-20210105211506424"></p><p>那么，只要在第四题<code>3 0</code>后面加上这个<code>DrEvil</code>就可以进入彩蛋啦~</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105211727580.png" alt="image-20210105211727580"></p><p>我这里假设输入123，但是我不确定需要输入的东西是什么，可能是字符串，数组等等。</p><pre><code class="hljs assembly"># secret_phase401248:ba 0a 00 00 00       mov    $0xa,%edx40124d:be 00 00 00 00       mov    $0x0,%esi401252:48 89 c7             mov    %rax,%rdi401255:e8 76 f9 ff ff       callq  400bd0 &lt;strtol@plt&gt;40125a:48 89 c3             mov    %rax,%rbx40125d:8d 40 ff             lea    -0x1(%rax),%eax401260:3d e8 03 00 00       cmp    $0x3e8,%eax401265:76 05                jbe    40126c &lt;secret_phase+0x2a&gt;401267:e8 ce 01 00 00       callq  40143a &lt;explode_bomb&gt;</code></pre><p><code>edx</code>为10，<code>esi</code>为0。</p><p>在<code>0x401265</code>打点，查看寄存器<code>rax</code></p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105212819389.png" alt="image-20210105212819389"></p><p><code>rax</code>是<code>strtol</code>函数的返回值，具有减一操作，并且与<code>0x3e8</code>也就是<code>1000</code>比较，无疑，我们输入的东西是一个数字。 并且在<code>1~10001</code>之间</p><pre><code class="hljs assembly">40126c:89 de                mov    %ebx,%esi40126e:bf f0 30 60 00       mov    $0x6030f0,%edi401273:e8 8c ff ff ff       callq  401204 &lt;fun7&gt;401278:83 f8 02             cmp    $0x2,%eax</code></pre><p><code>edi</code>是一个参数，<code>esi</code>是第二个参数，<code>esi</code>的值为<code>0</code>，我们可以打点查看<code>0x6030f0</code>值是多少。</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105213359345.png" alt="image-20210105213359345"></p><p>有了链表的经验，我们不能武断地认为这是一个数组，什么数据结构需要看他占用的大小和使用方式</p><pre><code class="hljs assembly"># fun7  401208:48 85 ff             test   %rdi,%rdi  40120b:74 2b                je     401238 &lt;fun7+0x34&gt;  ...  401238:b8 ff ff ff ff       mov    $0xffffffff,%eax  40123d:48 83 c4 08          add    $0x8,%rsp</code></pre><p>这段代码的意思是,如果<code>rdi</code>的值为0,就将<code>eax</code>拉满，但是我们知道，<code>rdi</code>是一个地址。</p><pre><code class="hljs assembly">40120f:39 f2                cmp    %esi,%edx401211:7e 0d                jle    401220 &lt;fun7+0x1c&gt;...401220:b8 00 00 00 00       mov    $0x0,%eax401225:39 f2                cmp    %esi,%edx401227:74 14                je     40123d &lt;fun7+0x39&gt;401229:48 8b 7f 10          mov    0x10(%rdi),%rdi40122d:e8 d2 ff ff ff       callq  401204 &lt;fun7&gt;401232:8d 44 00 01          lea    0x1(%rax,%rax,1),%eax401236:eb 05                jmp    40123d &lt;fun7+0x39&gt;</code></pre><p>有没有很熟悉？这段代码和第四题如出一辙，但是没有二分。</p><p>如果小于等于就跳转，将<code>eax</code>设置为0,如果相等就直接返回，不相等就继续递归，直到找到<code>rsi</code>与<code>rdx</code>相等的值,然后在这里是<code>2*%rax+1</code>，其中<code>rsi</code>是固定不变的我们输入的值(而不是减一后的值，前面的代码<code>40126c:    89 de                    mov    %ebx,%esi</code>)</p><pre><code class="hljs assembly">401213:48 8b 7f 08          mov    0x8(%rdi),%rdi401217:e8 e8 ff ff ff       callq  401204 &lt;fun7&gt;40121c:01 c0                add    %eax,%eax40121e:eb 1d                jmp    40123d &lt;fun7+0x39&gt;</code></pre><p>这段代码就是大于的情况。</p><p>其中最关键的点，也是困惑了我很久的点，在于这两个代码</p><pre><code class="hljs assembly">401213:48 8b 7f 08          mov    0x8(%rdi),%rdi401229:48 8b 7f 10          mov    0x10(%rdi),%rdi</code></pre><p>其中<code>rdi</code>是起始地址，那么<code>0x8</code>以及<code>0x10</code>就是往下一个数据迭代的过程。由于都是<code>0x8</code>的倍数，我就<strong>很自然</strong>认为每个数据占的字节大小为8</p><p>调试</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105215048697.png" alt="image-20210105215048697"></p><p>最前面的数字<code>36</code>是值，然后后面的<code>6304016</code>等，完全不知道是什么意思。但是后面发现<code>+0x8</code>然后发现对应的是<code>6304016</code>这个值，<code>+0x10</code>对应的值是<code>6304048</code>。根据我们能看懂的数据，这个数据块的大小应该是<code>0x16</code></p><p>后来，我把显示化作了16进制</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210105215750028.png" alt="image-20210105215750028"></p><p>豁然开朗，这是一个<strong>二叉树</strong>！后面的0是地址对齐</p><p>接下来的问题就迎刃而解了，我们可以画一张二叉树的图</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210106085132843.png" alt="image-20210106085132843"></p><p>可以观察到，以上的叶子节点的左右指针都是<code>0</code>，也就是<code>nullptr</code>呼应了上面地址为0就将<code>eax</code>设置为<code>$0xffffffff</code>。</p><p>所以，我们<strong>输入的值一定是在这个节点</strong>里面的</p><p><code>cmp    $0x2,%eax</code></p><p>由此段代码得知，最后的返回值是<code>2</code>。关于<code>eax</code>的计算，可以参考第四题，这里我们需要关注的是左右节点的选择。<strong>如果输入比当前节点小或者等于，就走左边，反之右边。</strong>通过观察我们可以发现，这是一个完全二叉搜索树。</p><p>通过<code>2*eax+1</code>或者<code>2+eax</code>的计算，可以推算出答案</p><p><code>22</code>或者<code>20</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一共七道题目，答案如下</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20210106090448171.png" alt="image-20210106090448171"></p><p>刚开始接触这个实验的时候，感到十分棘手，虽然我学习过汇编，但是是Intel汇编和本书的ATT汇编，在指令上是相反的，导致我一开始完全不看懂题目。</p><p>一共七道题目，参考了第一题和第二题，后面的除了彩蛋的发现，都是自己琢磨了很久才发现答案的。在我看来，这个<code>bomb</code>实验和<code>datalab</code>是完全不同画风的实验。<code>datalab</code>像我这种智商欠费的人，不会做就是不会做。<code>bomb</code>只要有<strong>耐心</strong>，就可以做完。</p><p>第一次见到实验题中还有彩蛋的，ORZ</p>]]></content>
    
    
    <categories>
      
      <category>csapp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chisel测试问题</title>
    <link href="/WennyAhhh.github.io/2020/12/30/chisel%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/WennyAhhh.github.io/2020/12/30/chisel%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="chisel测试问题"><a href="#chisel测试问题" class="headerlink" title="chisel测试问题"></a>chisel测试问题</h1><p>查了一下<a href="https://github.com/schoeberl/chisel-book">相关的资料</a>（第三章），找到了这个图。</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201230110219093.png" alt="image-20201230110219093"></p><p>关于函数传参中可能出现的疑惑，我也在<a href="https://blog.csdn.net/qq_34291505/article/details/87880730">其他资料</a>中找到了。的确是柯里化，只是因为scala的函数字面量有些晦涩</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201229231208573.png" alt="image-20201229231208573"></p><p>代码中用的是<strong>chisel3.iotesters</strong>这个模块，这个模块是<code>chisel</code>的测试模块（<a href="https://www.chisel-lang.org/api/chisel-testers/1.3.4/chisel3/iotesters/index.html">官方api资料</a>），可以搭配<code>verilator</code>仿真，即使我加入了参数，使用了<code>verilator</code>，测试还是调用<code>chisel</code>的这个模块而已，所以用于测试的模块到底来说都是同一个，都是依靠以下<code>TesterSimple</code>进行输出测试信息的，而这个类是使用<strong>chisel3.iotesters</strong>所需要的参数的组成部分，和有没有参数是<strong>没有关系</strong>的。</p><p>这个是测试模块，需要继承测试的类。</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201230101754905.png" alt="image-20201230101754905"></p><p><strong>chisel3.iotesters.Driver</strong>需要创建第二参数列表，也就是一个测试类，创建了这个测试类才能进行测试。如果需要生成其他文件就要使用execute函数，比如vcd。就可以再使用一个至于参数，不仅仅只有verilator这一个，我还找到其他参数，其中就包括以下这个，这个参数就直接生成vcd文件而没有cpp等文件了。如果没有使用参数，但是使用了<strong>chisel3.iotesters.Driver</strong>，有测试信息，并且但是没有vcd文件。</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201230094333316.png" alt="image-20201230094333316"></p><p>如果不加这个模块就不会进行测试了。就是另外一个方向了（但是查看<a href="https://www.chisel-lang.org/api/latest/chisel3/Driver$.html">文档</a>这个execute函数被弃用了）。</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201230094753723.png" alt="image-20201230094753723"></p><p>这样就没有测试信息提示了，并且生成Verilog文件。</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201230101527999.png" alt="image-20201230101527999"></p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201230094926684.png" alt="image-20201230094926684"></p><p>代码：</p><pre><code class="hljs scala"><span class="hljs-keyword">import</span> chisel3._<span class="hljs-keyword">import</span> chisel3.<span class="hljs-type">Driver</span><span class="hljs-keyword">import</span> chisel3.iotesters.<span class="hljs-type">PeekPokeTester</span><span class="hljs-keyword">import</span> org.scalatest._<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeviceUnderTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span></span>&#123;    <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>&#123;        <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span> (<span class="hljs-number">4.</span><span class="hljs-type">W</span>))        <span class="hljs-keyword">val</span> b = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span> (<span class="hljs-number">4.</span><span class="hljs-type">W</span>))        <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">2.</span><span class="hljs-type">W</span>))    &#125;)    io.out := io.a &amp; io.b&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TesterSimple</span>(<span class="hljs-params">dut : <span class="hljs-type">DeviceUnderTest</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">PeekPokeTester</span>(<span class="hljs-params">dut</span>)</span>&#123;    poke(dut.io.a, <span class="hljs-number">3.</span><span class="hljs-type">U</span>)    poke(dut.io.b, <span class="hljs-number">1.</span><span class="hljs-type">U</span>)    step(<span class="hljs-number">1000</span>)    <span class="hljs-comment">//println(&quot;Result is: &quot;+peek(dut.io.out).toString)</span>    expect(dut.io.out,<span class="hljs-number">1</span>)    poke(dut.io.a, <span class="hljs-number">2.</span><span class="hljs-type">U</span>)    poke(dut.io.b, <span class="hljs-number">0.</span><span class="hljs-type">U</span>)    step(<span class="hljs-number">1000</span>)    <span class="hljs-comment">//println(&quot;Result is: &quot;+peek(dut.io.out).toString)</span>    expect(dut.io.out,<span class="hljs-number">0</span>)&#125;<span class="hljs-comment">//直接生产vcd文件</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TesterSimple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span></span>&#123;    chisel3.iotesters.<span class="hljs-type">Driver</span>.execute(<span class="hljs-type">Array</span>(<span class="hljs-string">&quot;--generate-vcd-output&quot;</span>, <span class="hljs-string">&quot;on&quot;</span>),() =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">DeviceUnderTest</span>())&#123;         c =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">TesterSimple</span>(c)    &#125;&#125;<span class="hljs-comment">//需要自行添加参数</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TesterSimple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span></span>&#123;    chisel3.iotesters.<span class="hljs-type">Driver</span>.execute(args,() =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">DeviceUnderTest</span>())&#123;         c =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">TesterSimple</span>(c)    &#125;&#125;<span class="hljs-comment">//chisel验证，不生成文件，有测试信息</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TesterSimple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span></span>&#123;    chisel3.iotesters.<span class="hljs-type">Driver</span>(() =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">DeviceUnderTest</span>())&#123;         c =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">TesterSimple</span>(c)    &#125;&#125;<span class="hljs-comment">//生产verilog文件，但是没有测试信息</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TesterSimple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;  chisel3.<span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">DeviceUnderTest</span>())&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>riscv</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chisel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 300.最长递增子序列</title>
    <link href="/WennyAhhh.github.io/2020/12/26/LeetCode%20300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/WennyAhhh.github.io/2020/12/26/LeetCode%20300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/submissions/">LeetCode</a></p><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>dp[i] 表示 nums数组中0 ~ i之间的最大上升序列</p><p>状态转移方程:</p><p>​<br>$$<br>dp[i] = max(dp[j]) + 1,  0 &lt;j&lt; i-1, nums[j] &lt; nums[i]<br>$$</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-keyword">int</span> imax = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i &lt; n; i++)&#123;            dp[i] = <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[i]) &#123;                    dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>);                &#125;            &#125;            imax = max(imax, dp[i]);        &#125;        <span class="hljs-keyword">return</span> imax;    &#125;&#125;;</code></pre><p>$$<br>时间复杂度为： O(n^2)<br>$$</p><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>暴力＋剪枝</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201226102240027.png" alt="image-20201226102240027"></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> imax=<span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result,<span class="hljs-keyword">int</span> position)</span></span>&#123;        <span class="hljs-keyword">if</span>(position&lt;result.size())&#123;            <span class="hljs-keyword">if</span>(result[position])&#123;                <span class="hljs-keyword">return</span> result[position];            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=position+<span class="hljs-number">1</span>;i&lt;nums.size();i++)&#123;                <span class="hljs-keyword">if</span>(nums[i]&gt;nums[position])&#123;                    result[position]=max(result[position],getLength(nums,result,i)+<span class="hljs-number">1</span>);                &#125;            &#125;            <span class="hljs-keyword">return</span> result[position]?result[position]:<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;            imax=max(imax,getLength(nums,result,i));        &#125;        <span class="hljs-keyword">return</span> imax;    &#125;&#125;;</code></pre><h2 id="贪心-二分"><a href="#贪心-二分" class="headerlink" title="贪心+二分"></a>贪心+二分</h2><p>这个方法其实很巧妙</p><p>如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p><p>下面的是官方的解析，官方还是一如既往的严谨。</p><blockquote><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/</a><br>来源：力扣（LeetCode）</p></blockquote><p>其实简单来说，将不重复的数字换入到返回的结果数组<code>res</code>中，由于只是交换，并不改变其长度，并且使这个序列上升的很慢。虽然这个序列有时候是不合法的，但是，如果<code>res</code>中最后一个数组被替换，那么就变为合法的了。</p><p>利用二分法，可以在<code>logN</code>的时间复杂度中找到需要找到的位置： 第一个等于或者大于nums[i]</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-keyword">if</span>(!n)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;        res.push_back(nums[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span>(res.back() &lt; nums[i])&#123;                res.push_back(nums[i]);                len ++;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.back() &gt; nums[i])&#123;                <span class="hljs-comment">//二分查找</span>                <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;                <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;                <span class="hljs-keyword">while</span>(left &lt;= right)&#123;                    <span class="hljs-comment">//找到第一个比num[i]大的数</span>                    <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;                    <span class="hljs-keyword">if</span>(res[mid] &gt;= nums[i]) &#123;                        right = mid - <span class="hljs-number">1</span>;                    &#125;                    <span class="hljs-keyword">else</span>&#123;                        left = mid + <span class="hljs-number">1</span>;                    &#125;                &#125;                <span class="hljs-keyword">if</span>(res[left] != nums[i]) &#123;                    res[left] = nums[i];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> len;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rocket环境配置</title>
    <link href="/WennyAhhh.github.io/2020/12/13/%E5%AE%89%E8%A3%85chisel/"/>
    <url>/WennyAhhh.github.io/2020/12/13/%E5%AE%89%E8%A3%85chisel/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这个环境我安装了挺久了，分别在ubuntu和centos中安装。对于chisel和rocket-chip其实并没有改变多少。由于在rocket-chip的官方教程中有rocket-tools，我也没有多想就尝试安装，结果子模块会出现各种各样的问题，最开始由于渣渣校园网导致经常下载到一半断网，借了个教师账号才下载完成。编译中遇到各种稀奇古怪的编译问题，有些问题甚至google不到，最终都是通过下载官方github编译运行的。</p><p>后来发现我的任务好像只是运行rocket-chip</p><h1 id="安装chisel"><a href="#安装chisel" class="headerlink" title="安装chisel"></a>安装chisel</h1><p>安装sbt</p><pre><code class="hljs bash">curl https://bintray.com/sbt/rpm/rpm &gt; bintray-sbt-rpm.reposudo mv bintray-sbt-rpm.repo /etc/yum.repos.d/sudo yum install sbt<span class="hljs-comment"># 运行一下，可能需要很长时间</span>sbt</code></pre><p>安装verilator</p><pre><code class="hljs bash"><span class="hljs-comment">#Verilog源码编译成单/多线程的C++源代码来进行仿真</span>sudo yum install verilator</code></pre><p>安装chisel</p><pre><code class="hljs bash">wget https://github.com/chipsalliance/chisel3/archive/v3.4.0.tar.gztar xvzf v3.4.0.tar.gz<span class="hljs-built_in">cd</span> chisel3-3.4.0</code></pre><p>体验包</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/ucb-bar/chisel-tutorial.git<span class="hljs-built_in">cd</span> chisel-tutorialgit fetch origingit fetch originsbt run</code></pre><p>这里的chisel-tutorial的build.sbt需要修改。</p><p>libraryDependencies的各种组件可能因为版本原因，需要升级。可以在<a href="https://mvnrepository.com/artifact/edu.berkeley.cs">https://mvnrepository.com/artifact/edu.berkeley.cs</a>      中寻找最新的模块</p><pre><code class="hljs scala"><span class="hljs-comment">// build.sbt</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scalacOptionsVersion</span></span>(scalaVersion: <span class="hljs-type">String</span>): <span class="hljs-type">Seq</span>[<span class="hljs-type">String</span>] = &#123;  <span class="hljs-type">Seq</span>() ++ &#123;    <span class="hljs-comment">// If we&#x27;re building with Scala &gt; 2.11, enable the compile option</span>    <span class="hljs-comment">//  switch to support our anonymous Bundle definitions:</span>    <span class="hljs-comment">//  https://github.com/scala/bug/issues/10047</span>    <span class="hljs-type">CrossVersion</span>.partialVersion(scalaVersion) <span class="hljs-keyword">match</span> &#123;      <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>((<span class="hljs-number">2</span>, scalaMajor: <span class="hljs-type">Long</span>)) <span class="hljs-keyword">if</span> scalaMajor &lt; <span class="hljs-number">12</span> =&gt; <span class="hljs-type">Seq</span>()      <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;-Xsource:2.11&quot;</span>)    &#125;  &#125;&#125; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">javacOptionsVersion</span></span>(scalaVersion: <span class="hljs-type">String</span>): <span class="hljs-type">Seq</span>[<span class="hljs-type">String</span>] = &#123;  <span class="hljs-type">Seq</span>() ++ &#123;    <span class="hljs-comment">// Scala 2.12 requires Java 8. We continue to generate</span>    <span class="hljs-comment">//  Java 7 compatible code for Scala 2.11</span>    <span class="hljs-comment">//  for compatibility with old clients.</span>    <span class="hljs-type">CrossVersion</span>.partialVersion(scalaVersion) <span class="hljs-keyword">match</span> &#123;      <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>((<span class="hljs-number">2</span>, scalaMajor: <span class="hljs-type">Long</span>)) <span class="hljs-keyword">if</span> scalaMajor &lt; <span class="hljs-number">12</span> =&gt;        <span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;-source&quot;</span>, <span class="hljs-string">&quot;1.7&quot;</span>, <span class="hljs-string">&quot;-target&quot;</span>, <span class="hljs-string">&quot;1.7&quot;</span>)      <span class="hljs-keyword">case</span> _ =&gt;        <span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;-source&quot;</span>, <span class="hljs-string">&quot;1.8&quot;</span>, <span class="hljs-string">&quot;-target&quot;</span>, <span class="hljs-string">&quot;1.8&quot;</span>)    &#125;  &#125;&#125; name := <span class="hljs-string">&quot;MyChisel&quot;</span>version := <span class="hljs-string">&quot;3.2-SNAPSHOT&quot;</span>scalaVersion := <span class="hljs-string">&quot;2.12.6&quot;</span>crossScalaVersions := <span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;2.11.12&quot;</span>, <span class="hljs-string">&quot;2.12.4&quot;</span>) resolvers += <span class="hljs-string">&quot;My Maven&quot;</span> at <span class="hljs-string">&quot;https://raw.githubusercontent.com/sequencer/m2_repository/master&quot;</span><span class="hljs-comment">// bug fix from https://github.com/freechipsproject/chisel3/wiki/release-notes-17-09-14</span>scalacOptions ++= <span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;-Xsource:2.11&quot;</span>) libraryDependencies += <span class="hljs-string">&quot;edu.berkeley.cs&quot;</span> %% <span class="hljs-string">&quot;chisel3&quot;</span> % <span class="hljs-string">&quot;3.4.0&quot;</span>libraryDependencies += <span class="hljs-string">&quot;edu.berkeley.cs&quot;</span> %% <span class="hljs-string">&quot;chisel-iotesters&quot;</span> % <span class="hljs-string">&quot;1.5.0&quot;</span>libraryDependencies += <span class="hljs-string">&quot;edu.berkeley.cs&quot;</span> %% <span class="hljs-string">&quot;chisel-testers2&quot;</span> % <span class="hljs-string">&quot;0.2.2&quot;</span>libraryDependencies += <span class="hljs-string">&quot;edu.berkeley.cs&quot;</span> %% <span class="hljs-string">&quot;rocketchip&quot;</span> % <span class="hljs-string">&quot;1.2.2&quot;</span> scalacOptions ++= scalacOptionsVersion(scalaVersion.value)javacOptions ++= javacOptionsVersion(scalaVersion.value)</code></pre><p>可以尝试运行一下</p><pre><code class="hljs scala"><span class="hljs-comment">// 在chisel-tutorial/src/main/scala文件夹里创建一个文件，命名为AND.scala，输入以下内容并保存：</span><span class="hljs-comment">// AND.scala</span><span class="hljs-keyword">package</span> test <span class="hljs-keyword">import</span> chisel3._<span class="hljs-keyword">import</span> chisel3.experimental._ <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AND</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RawModule</span> </span>&#123;  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span> &#123;    <span class="hljs-keyword">val</span> a = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))    <span class="hljs-keyword">val</span> b = <span class="hljs-type">Input</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))    <span class="hljs-keyword">val</span> c = <span class="hljs-type">Output</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">1.</span><span class="hljs-type">W</span>))  &#125;)   io.c := io.a &amp; io.b&#125;</code></pre><pre><code class="hljs scala"><span class="hljs-comment">// 在chisel-tutorial/src/test/scala文件夹里创建一个文件，命名为ANDtest.scala，输入以下内容并保存</span><span class="hljs-comment">// ANDtest.scala</span><span class="hljs-keyword">package</span> test <span class="hljs-keyword">import</span> chisel3._ <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">testMain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;  <span class="hljs-type">Driver</span>.execute(args, () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">AND</span>)&#125;</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 在chisel-tutorial中运行</span>sbt <span class="hljs-string">&quot;test:runMain test.testMain --target-dir generated/and&quot;</span></code></pre><p>结果可以在generate的中得到需要的Verilog代码</p><h1 id="Rocket-tools"><a href="#Rocket-tools" class="headerlink" title="Rocket-tools"></a>Rocket-tools</h1><p>本安(xin)装(lu)教(li)程(cheng)不保证时效性。以官方教程为主。注意区分路径，还有google的蛋疼翻译。</p><p>官网的环境依赖，但是在centos有些不可以用，有些版本太低了。不建议没有代理工具安装，即使可以利用码云，zygxsq.cn。因为他包括很多子模块，地址也都是github。当然要是有心情的话可以慢慢修改<code>.gitmoudle</code>文件，但是限于子模块实在太多，这个项目的子模块嵌套了三层，不建议这样做。</p><p>在ubuntu上有时候automake版本够了仍然报错</p><p>gcc版本要高</p><pre><code class="hljs bash"><span class="hljs-comment"># 升级gcc</span>yum install -y centos-release-sclyum install -y devtoolset-6-gcc devtoolset-8-gcc-c++<span class="hljs-built_in">source</span> /opt/rh/devtoolset-8/<span class="hljs-built_in">enable</span></code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 官方依赖，有些在centos官方库没有，有些版本太低。</span>sudo yum -y install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># automake官方库版本低，查到的资料里还有autoconf，顺便也升级了一下</span>sudo rpm -e --nodeps autoconf-2.63 wget http://ftp.gnu.org/gnu/autoconf/autoconf-2.70.tar.gztar zxvf autoconf-2.70.tar.gz<span class="hljs-built_in">cd</span> autoconf-2.70sudo ./configure --prefix=/usrsudo make &amp;&amp; make installrpm -e --nodeps automakewget http://ftp.gnu.org/gnu/automake/automake-1.16.3.tar.gztar zxvf automake-1.16.3.tar.gz<span class="hljs-built_in">cd</span> automake-1.16.3./configure --prefix=/usrmake &amp;&amp; make install</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 安装 device-tree-compiler</span>yum install dtc<span class="hljs-comment"># zlib</span>yum install -y zlib zlib-devel</code></pre><p>前面只是<strong>最简单</strong>的前置工作。</p><p>后续工作中需要注意的是路径地址</p><pre><code class="hljs bash"><span class="hljs-comment"># 编译之后保存的地址</span><span class="hljs-built_in">export</span> RISCV=/home/chaikaichen/to/install/riscv/toolchain<span class="hljs-comment"># 保存在运行在riscv上的工具，比如gcc。</span><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$RISCV</span>/bin:<span class="hljs-variable">$PATH</span></code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 设置环境变量，注意路径</span><span class="hljs-built_in">export</span> RISCV=/home/chaikaichen/to/install/riscv/toolchain<span class="hljs-comment"># rocket工具链</span>https://github.com/chipsalliance/rocket-tools<span class="hljs-comment"># 下载子模块。这个子模块相对而言很大，其中有个riscv-qemu，官方master已经关了，所以没有git https了，只有git://。这个url导致代理直接失效，70k/s已经很幸福了</span><span class="hljs-comment"># 当遇到这个子模块，玄学一点，多试一试 git submodule update --init --recursive ，诚意够了，速度就上300K/s。</span>git submodule update --init --recursive</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># N是几个核的意思，取决于cpu或者虚拟机设置。手冷可以多开一点取暖</span><span class="hljs-built_in">export</span> MAKEFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$MAKEFLAGS</span> -jN&quot;</span><span class="hljs-comment"># 自带的riscv-gnu-toolchain版本有些低，make的时候出现error。需要重下</span>rm -rf riscv-gnu-toolchaingit <span class="hljs-built_in">clone</span> https://github.com/riscv/riscv-gnu-toolchain<span class="hljs-built_in">cd</span> riscv-gnu-toolchaingit submodule update --init --recursive./configure --prefix=<span class="hljs-variable">$RISCV</span>make<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$RISCV</span>/bin:<span class="hljs-variable">$PATH</span><span class="hljs-comment"># 会有各种各样的错误，我差点给跪下了</span><span class="hljs-comment"># 需要编译很长时间，还会有各种error和fatal。看到warning就谢天谢地吧</span><span class="hljs-built_in">cd</span> .../build.sh</code></pre><p>我在编译运行时，有时候运行会错误，导致后续的无法编译。例如我在运行过程中<code>riscv-tests</code>无法编译。可能不是环境问题<del>不知道的统统是版本问题</del>.直接删除这个子模块，在官方github中下载，编译，例如<code>riscv-tests</code>。但是此方法一定要先编译运行<code>riscv-gnu-toolchain</code>因为要用到gcc</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/riscv/riscv-tests<span class="hljs-built_in">cd</span> riscv-testsgit submodule update --init --recursiveautoconf./configure --prefix=<span class="hljs-variable">$RISCV</span>/targetmakemake install</code></pre><p>路径里面好像没有<code>pk</code>,那就直接放进去</p><pre><code class="hljs awk">cp pk dummy_payload config.status bbl_payload bbl <span class="hljs-regexp">/home/</span>chaikaichen<span class="hljs-regexp">/to/i</span>nstall<span class="hljs-regexp">/riscv/</span>toolchain/bin</code></pre><p>测试</p><p>编写hello.c文件</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>编译运行</p><pre><code class="hljs bash">riscv64-unknown-elf-gcc  -o  hello hello.c</code></pre><pre><code class="hljs bash">spike pk hello</code></pre><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/image-20201213124721369.png" alt="image-20201213124721369"></p><p>证明工具链什么的已经跑通了</p><p>vcs仿真暂时没有尝试</p><h1 id="Rocket-Chip"><a href="#Rocket-Chip" class="headerlink" title="Rocket-Chip"></a>Rocket-Chip</h1><pre><code class="hljs bash"><span class="hljs-comment"># 下载官方库 rocket-chip</span>git <span class="hljs-built_in">clone</span> https://github.com/ucb-bar/rocket-chip.git<span class="hljs-built_in">cd</span> rocket-chip<span class="hljs-comment"># 下载子模块，这个子模块还算简单</span>git submodule update --init</code></pre><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> rocket-chipsbt<span class="hljs-built_in">cd</span> ..<span class="hljs-built_in">cd</span> rocket-chip/chisel3sbt<span class="hljs-built_in">cd</span> ..<span class="hljs-built_in">cd</span> rocket-chip/firrtlsbt<span class="hljs-built_in">cd</span> ..<span class="hljs-built_in">cd</span> rocket-chip/vsim<span class="hljs-comment"># 如果可以生成generated-src代表生成了RTL</span>make verilog CONFIG=freechips.rocketchip.system.DefaultSmallConfig</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_26657901/article/details/89115070">https://blog.csdn.net/qq_26657901/article/details/89115070</a></p><p><a href="https://www.cnblogs.com/mikewolf2002/p/10799553.html">https://www.cnblogs.com/mikewolf2002/p/10799553.html</a></p><p><a href="https://blog.csdn.net/a_weiming/article/details/87651285?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control">https://blog.csdn.net/a_weiming/article/details/87651285?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control</a></p><p><a href="https://blog.csdn.net/qq_34291505/article/details/87365907">https://blog.csdn.net/qq_34291505/article/details/87365907</a></p><p><a href="https://blog.csdn.net/qq_41976613/article/details/89629372">https://blog.csdn.net/qq_41976613/article/details/89629372</a></p><p><a href="https://github.com/chipsalliance/rocket-tools">https://github.com/chipsalliance/rocket-tools</a></p><p><a href="https://github.com/ucb-bar/chisel-tutorial">https://github.com/ucb-bar/chisel-tutorial</a></p><p><a href="https://github.com/chipsalliance/rocket-chip">https://github.com/chipsalliance/rocket-chip</a></p>]]></content>
    
    
    <categories>
      
      <category>riscv</category>
      
    </categories>
    
    
    <tags>
      
      <tag>riscv</tag>
      
      <tag>rocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>epoll浅析</title>
    <link href="/WennyAhhh.github.io/2020/12/10/epoll%E6%B5%85%E6%9E%90/"/>
    <url>/WennyAhhh.github.io/2020/12/10/epoll%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="epoll浅析"><a href="#epoll浅析" class="headerlink" title="epoll浅析"></a>epoll浅析</h1><blockquote><p>承接上次写的博客，阻塞和非阻塞的那一部分，最开始是源于对epoll工作模式的疑惑。在看了很多大佬的博文和epoll的源码之后，整理了一下epoll的基本工作方式和用法。</p><p>网上的博客良莠不齐，需要自己思考才能有所收获。（当然我这篇也只是我的个人见解，没有什么权威性，千万不要把我下面尤其是括号中的东西当做真真确确的东西。</p></blockquote><h2 id="epoll系列系统调用"><a href="#epoll系列系统调用" class="headerlink" title="epoll系列系统调用"></a>epoll系列系统调用</h2><p>epoll主要是下面三个函数。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;says/epoll.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">( 内核事件的大小 )</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">( 内核事件表的文件描述符，操作类型（添加，修改，删除），添加用户关系的文件描述符，事件类型)</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">( 内核事件表的文件描述符，就绪事件数组，最多监听多少个事件，阻塞时间)</span></span></code></pre><p>epoll_create 用于<strong>创建</strong>一个内核事件表的文件描述符，一般一个程序只创建一个<br>epoll_ctl   用于<strong>操作</strong>用户关心的文件描述符。其中的<code>op</code>参数</p><table><thead><tr><th align="center">EPOLL_CTL_ADD</th><th>添加</th></tr></thead><tbody><tr><td align="center">EPOLL_CTL_MOD</td><td>修改</td></tr><tr><td align="center">EPOLL_CTL_DEL</td><td>删除</td></tr></tbody></table><p>epoll_wait 它在一段<strong>超时等待</strong>事件内等待一组文件描述符上的事件。就是当IO事件的第一个阶段完成，文件描述符转化为就绪事件，就会触发这个函数。其中的细节后续再谈，</p><p>epoll相对于poll和select，将触发就绪事件和注册事件分开。观察最常使用的<code>epoll_wait()</code>,就会发现：就绪事件，也就是第二个参数，是从函数内部通过指针传递过来的，相对而言入参很少。这样就避免了<code>select/poll</code>每次调用都要重新加入文件描述符/事件数组。</p><p><code>select/pol</code>l每次都会返回全部的事件数组，但是其中还包括了没有就绪的事件，这个是我们不需要处理的。所以他们寻找就绪事件的事件复杂度为<code>O(n)</code>。<br>epoll返回的都是就绪事件，他寻找就绪事件的事件复杂度为<code>O(1)</code>。</p><h2 id="概念和主要数据结构"><a href="#概念和主要数据结构" class="headerlink" title="概念和主要数据结构"></a>概念和主要数据结构</h2><p>在学习epoll的时候，我困惑于书上的一句话</p><blockquote><p>epoll_wait则不同，他采用的是回调的方式。内核监测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。</p></blockquote><p>既然触发了回调函数，那么epoll不是异步的么？那为什么说epoll是同步？</p><p>回答此问题需要明白epoll的工作原理。我们需要一些了解一些东西。</p><h3 id="同步，异步"><a href="#同步，异步" class="headerlink" title="同步，异步"></a>同步，异步</h3><p>同步异步在另外的博客中提到过，不再赘述.</p><h3 id="mmap-epoll源码中没有使用"><a href="#mmap-epoll源码中没有使用" class="headerlink" title="mmap(epoll源码中没有使用)"></a>mmap(epoll源码中没有使用)</h3><p>(申请一块内存，将内核态内存映射到用户态，应该是从链表中的数据映射到数组中，避免copy操作。<del>但是仔细思考过又觉得很别扭。查看<code>mmap</code>函数，他需要传递一个文件描述符，这个文件描述符是需要映射的文件。但是在<code>epoll_wait</code>中，需要映射的空间是一个链表，里面包含多个文件描述符，但是<code>epoll_wait</code>只提供一个地址。这样问题就复杂起来了</del>，于是去查了一下这个问题，<strong>才发现！！！ epoll根本没有用mmap技术！</strong>，现在细品在侯捷老师那边听到的– <strong>源码面前了无秘密</strong>。感触良深）</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>用于在内核空间添加一个事件表，添加用户所关系的事件。对于普通的数组来说，一个文件描述符的插入或者删除操作，时间复杂度可以达到O(logN)。(至于为什么不用O(1)的哈希表?可能是因为像STL库中乘2太浪费空间时间了？如果不是这样操作，如果产生冲突可能时间复杂度也会到达O(N),当然只是我的猜测而已，大神的想法又不是我这种蒟蒻能揣测的)</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>双向链表，用于存放就绪事件。（为什么是双向链表？</p><h3 id="主要的数据结构"><a href="#主要的数据结构" class="headerlink" title="主要的数据结构"></a>主要的数据结构</h3><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">spin_lock_t</span> lock;            <span class="hljs-comment">//对本数据结构的访问</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mtx</span>;</span>            <span class="hljs-comment">//防止使用时被删除</span>    <span class="hljs-keyword">wait_queue_head_t</span> wq;        <span class="hljs-comment">//sys_epoll_wait() 使用的等待队列</span>    <span class="hljs-keyword">wait_queue_head_t</span> poll_wait; <span class="hljs-comment">//file-&gt;poll()使用的等待队列</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllist</span>;</span>    <span class="hljs-comment">//事件满足条件的链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">rbr</span>;</span>          <span class="hljs-comment">//用于管理所有fd的红黑树</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">ovflist</span>;</span>      <span class="hljs-comment">//将事件到达的fd进行链接起来发送至用户空间</span>&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">rbn</span>;</span>            <span class="hljs-comment">//用于主结构管理的红黑树</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllink</span>;</span>       <span class="hljs-comment">//事件就绪队列</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">next</span>;</span>           <span class="hljs-comment">//用于主结构体中的链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_filefd</span> <span class="hljs-title">ffd</span>;</span>         <span class="hljs-comment">//每个fd生成的一个结构</span>    <span class="hljs-keyword">int</span> nwait;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pwqlist</span>;</span>     <span class="hljs-comment">//poll等待队列</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span>          <span class="hljs-comment">//该项属于哪个主结构体</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">fllink</span>;</span>         <span class="hljs-comment">//链接fd对应的file链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>;</span>  <span class="hljs-comment">//注册的感兴趣的事件,也就是用户空间的epoll_event</span>&#125;</code></pre><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>调用<code>epoll_create()</code>在内核中创建一个事件表，然后调用<code>epoll_ctl()</code>添加文件描述符，最后用<code>epoll_wait()</code>等待就绪事件发生。</p><p>利用红黑树，可以防止同一个文件描述符<code>fd</code>重复添加到事件列表中。当添加了用户关心事件的文件描述符被加入到红黑树中时，都会有一个回调函数<code>ep_poll_callback</code>与这个文件描述符绑定。这个回调函数也就是上面提出问题的那个回调函数。</p><p>当事件发生之后，就会触发这个回调函数，将该就绪事件添加到<strong>双向链表</strong>当中去。到这里，之前的问题就可以解答了： 这个回调函数只是将文件描述符添加到链表当中去，而不是用于返回<code>epoll_wait</code>。</p><p>在调用epoll_wait时，只需要<strong>去重</strong>，然后返回。去重的原因，可能有事件重复触发了几次，我们只需要一次就够了。（双向链表，红黑树，是否可以提出一个问题 – 在内核空间中，连续的空间是否比较少。</p><p><img src="https://img2018.cnblogs.com/blog/1300168/201811/1300168-20181121194549799-1443021669.jpg" alt="img"></p><h2 id="电平触发（LT-边沿触发（ET）"><a href="#电平触发（LT-边沿触发（ET）" class="headerlink" title="电平触发（LT)   边沿触发（ET）"></a>电平触发（LT)   边沿触发（ET）</h2><p>epoll对文件描述符的操作有两种模式，电平触发（LT）和边沿触发（ET）。默认情况下是电平触发。这两个模式是放在<code>epoll_event.events</code>中，用<code>|</code>进行设置。</p><h3 id="LT"><a href="#LT" class="headerlink" title="LT"></a>LT</h3><p>对于采用LT工作模式的文件描述符，当<code>epoll_wait</code>检测到其上事件发生并将其通知到应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用<code>epoll_wait</code>时，<code>epoll_wait</code>还会再次向应用程序通告此事件，直到该数据被处理。</p><p>这是《Linux高性能服务器编程》的原话。为什么应用程序可以不立即处理这个事件？应用程序不是程序员自己写的么？事件来了为什么不进行操作？需要加什么标志位么？</p><p>知乎大佬的<a href="https://zhuanlan.zhihu.com/p/73231499">解释</a></p><blockquote><p>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p></blockquote><p>在LT模式下进行（需要设置偏移量？</p><p>​            读： 如果需要读的内存缓冲区一次没有读完，即内核缓冲区还有数据可读，读事件就一直触发</p><p>​            写： 发送缓冲区不满，可以继续写入数据，写事件一直触发</p><p>LT的读写取决于buff</p><p>在LT模式下，事件可以多次添加到<code>rdlist</code>链表当中，会被多次触发，可能会影响效率。</p><p><del>假设在多线程的情况下，可能会出现多个线程对一个文件描述符操作，那么会产生竞态环境。如果有线程对文件描述符进行操作，那么在LT模式下就会一直处于就绪态。</del>（这是我在看ET模式 <code>EPOLLONESHOT</code>事件产生的联想，仅是个人理解。但是在后续看到<code>惊群效应</code>的时候，<code>epoll</code>之所以没有像<code>accpet</code>一样采取措施防止惊群，是考虑到用户可能要在多个线程中对同一个文件描述符进行操作（应该是读操作吧，写操作会产生竞态环境）,那么按照我的思想来说，就不允许多个线程对同一个文件描述符进行操作，所以可能是错误的）</p><h3 id="ET"><a href="#ET" class="headerlink" title="ET"></a>ET</h3><p>在ET模式下，当<code>epoll-wait</code>检测到其上事件发生并将其上有事件发生并将此事件通知应用程序后，应用程序<strong>必须立即处理</strong>该事件，因为后续将不再通知这一事件（但是凡事都有例外）</p><p>​            读：当有就绪的读事件发生，只要buff中有数据，就应该读完</p><p>​            写： 只有buff中有数据没有写满，就一直写</p><p>ET模式下是看状态的转化</p><p>在ET模式下，每个文件描述符都应该是<strong>非阻塞</strong>的。如果文件描述符是阻塞的，那么由于读或者写操作而一直处于阻塞状态。而LT模式不会出现这种状况：第一次读取或者写一定可以成功，如果读或写完毕，就直接退出了。</p><p>由于<code>socket</code>是文件描述符，所以服务器在读取的时候客户端会一直发送消息，这样即使是在ET模式下也会以为数据过大而多次触发。</p><h4 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h4><p>我们期望一个socket上在任一时刻都只被一个线程处理。这时候我们可以在事件中注册<code>EPOLLONESHOT</code></p><p>对于注册了<code>EPOLLONESHOT</code>事件的文佳描述符，操作系统最多触发其上注册的一个可读可写或者异常事件（固定了线程PID？）这样其他线程就无法对其进行修改。</p><p>注册了<code>EPOLLONESHOT</code>事件的<code>socket</code>一旦被某个线程处理完毕，该线程就应该立即重置这个<code>socket</code>上的<code>EPOLLONESHOT</code>事件，以确保下一次可读，其他工作线程可以处理这个<code>socket</code></p><h3 id="LT模式和ET模式例子"><a href="#LT模式和ET模式例子" class="headerlink" title="LT模式和ET模式例子"></a>LT模式和ET模式例子</h3><p>书上的源码，稍微修改了一下。虽然是能编译过的，但是不保证逻辑的正确性，可以参考。（后续有时间可以改一下，贴一堆垃圾上来确实不好，但是最近有些忙碌，英语听力把人听傻了）</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt; //用于存放基本数据类型，一般系统编程都最好加上，有pid_t这种进程编号ID</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;     //socket套接字函数</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;       //定义数据结构socketaddr_in，这个数据结构用于存放ip地址</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;      //提供ip地址转换的函数</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;     //断言</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;  //标准输入输出</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;  //系统编程函数</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;  //报错，在本例中需要用到GAGAIN等，非阻塞时如果缓冲区没有东西出现的错误</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;     //string函数,可以用memset取代bzero初始化</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;  //可以修改文件描述符,把文件描述符转化成非阻塞这个段代码需要背出来</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;  //IO复用</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;    //多线程函数库，创建一个内核级线程</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENT_NUMBER 1024   <span class="hljs-comment">//最大事件的大小</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 10  <span class="hljs-comment">//缓冲区大小</span></span><span class="hljs-comment">//修改fd的状态，返回旧状态。fcntl这种函数完美符合2/8定律</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-keyword">int</span> fd )</span></span>&#123;    <span class="hljs-keyword">int</span> old_option = fcntl( fd, F_GETFL );    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;    fcntl( fd, F_SETFL, new_option);    <span class="hljs-keyword">return</span> old_option;&#125;<span class="hljs-comment">//调用epoll_ctl函数，这里只是加入，并且只加入了读事件，也就是EPOLLIN，通过bool来确定是那个模式（LT/ET),默认是LT</span><span class="hljs-comment">//我可以再添加写事件</span><span class="hljs-comment">//可以处理带外数据</span><span class="hljs-comment">//处理错误</span><span class="hljs-comment">//一般来说（看教材的），EPOLLIN，EPOLLOUT，EOLLERR用的比较多</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">bool</span> enable_et)</span></span>&#123;    epoll_event ev;    ev.data.fd = fd;    <span class="hljs-comment">//这里是有读事件，但是没有写事件，其实可以加上，但是后天就要考试啦！！！</span>    ev.events = EPOLLIN;    <span class="hljs-keyword">if</span>( enable_et )&#123;        ev.events |= EPOLLET;    &#125;     setnonblocking(fd);    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">newConnet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> listenfd,<span class="hljs-keyword">bool</span> flag)</span></span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span>    <span class="hljs-keyword">socklen_t</span> client_addresslength = <span class="hljs-keyword">sizeof</span> (client_address);    <span class="hljs-keyword">int</span> connfd = accept( listenfd,(struct sockaddr*)&amp;client_address,&amp;client_addresslength);    addfd( epollfd,connfd,flag);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lt</span><span class="hljs-params">(epoll_event* events, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> listenfd)</span></span>&#123;    <span class="hljs-keyword">char</span> buf[BUFFER_SIZE];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; number; i++)&#123;        <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;        <span class="hljs-keyword">if</span>(sockfd == listenfd)&#123;            newConnet(epollfd,listenfd,<span class="hljs-literal">false</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event trigger once\n&quot;</span>);            <span class="hljs-built_in">memset</span>(buf ,<span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);            <span class="hljs-keyword">int</span> ret = recv(sockfd,buf,BUFFER_SIZE<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span> )&#123;                close(sockfd);                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of connent: %s\n&quot;</span>,ret,buf);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLOUT)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;events trigger once\n&quot;</span>);            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* buf=<span class="hljs-string">&quot;chaij&#x27;s blog&quot;</span>;            <span class="hljs-keyword">int</span> ret = send(sockfd,buf,BUFFER_SIZE,<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)&#123;                close(sockfd);                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send %d bytes of connet\n&quot;</span>,ret);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timeout\n&quot;</span>);        &#125;    &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">et</span><span class="hljs-params">(epoll_event* events, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> listenfd)</span></span>&#123;    <span class="hljs-comment">//在ET模式下，文件描述符一定是非阻塞的，原因详见笔记</span>    <span class="hljs-keyword">char</span> buf[ BUFFER_SIZE ];    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)&#123;        <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;        <span class="hljs-keyword">if</span>(sockfd == listenfd)&#123;            newConnet(epollfd,listenfd,<span class="hljs-literal">true</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( events[i].events &amp; EPOLLIN)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;events trigger read once\n&quot;</span>);            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;                <span class="hljs-built_in">memset</span>(buf,<span class="hljs-string">&#x27;\0&#x27;</span>,BUFFER_SIZE);                <span class="hljs-keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);                <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span>)&#123;                    <span class="hljs-comment">//对于ET模式，也就是边缘触发，要求数据一次性读完。其实这样说是不正确的，当数据很大的时候，边缘读取其实到边缘也无法全部读取完毕</span>                    <span class="hljs-comment">//当无法读取的时候，会报错，EAGIN，意味再来一次，也就是说缓冲区已经被读取完毕</span>                    <span class="hljs-keyword">if</span>( (errno == EAGAIN ) || ( errno == EWOULDBLOCK) )&#123;                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read later\n&quot;</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                    close(sockfd);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)&#123;                    close( sockfd );                &#125;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf );                &#125;            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( events[i].events &amp; EPOLLOUT)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;events trigget write once\n&quot;</span>);            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* buf=<span class="hljs-string">&quot;chaij&#x27;s blog&quot;</span>;            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;                <span class="hljs-comment">//memset(buf,&#x27;\0&#x27;,BUFFER_SIZE);</span>                <span class="hljs-keyword">int</span> ret = send(sockfd, buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);                <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span>)&#123;                    <span class="hljs-comment">//对于ET模式，也就是边缘触发，要求数据一次性读完。其实这样说是不正确的，当数据很大的时候，边缘读取其实到边缘也无法全部读取完毕</span>                    <span class="hljs-comment">//当无法读取的时候，会报错，EAGIN，意味再来一次，也就是说缓冲区已经被读取完毕</span>                    <span class="hljs-keyword">if</span>( (errno == EAGAIN ) || ( errno == EWOULDBLOCK) )&#123;                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write later\n&quot;</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                    close(sockfd);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)&#123;                    close( sockfd );                &#125;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;write %d\n&quot;</span>,ret);                &#125;            &#125;        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happened \n&quot;</span>);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span>* argv[])</span></span>&#123;        <span class="hljs-keyword">if</span>(argc &lt;= <span class="hljs-number">2</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ip/port is empty\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//下面是最常用的socket编程过程</span>    <span class="hljs-comment">//listen 发生在第二次握手当中</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> port = atoi(argv[<span class="hljs-number">2</span>]);        <span class="hljs-keyword">int</span> ret=<span class="hljs-number">0</span>;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span>    <span class="hljs-built_in">memset</span>(&amp;address,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> address);    address.sin_port = htons(port);    address.sin_family = AF_INET;    inet_pton(AF_INET,ip,&amp;address.sin_addr);    <span class="hljs-keyword">int</span> listenfd = socket( PF_INET, SOCK_STREAM,<span class="hljs-number">0</span>);    assert(ret != <span class="hljs-number">-1</span>);    <span class="hljs-comment">//因为需要通用的地址，所以需要转换成统一的。虽然size不一样，但是可以利用变长数组</span>    ret = bind( listenfd, (struct sockaddr* )&amp;address, <span class="hljs-keyword">sizeof</span> address);    assert(ret != <span class="hljs-number">-1</span>);    <span class="hljs-comment">//绑定之后需要accpet读取数据,</span>    <span class="hljs-comment">//为什么有了acppet还需要使用epoll？accpet只能对应一个套接字，用完了就废弃了。最关键的是accpet出来的套接字没有</span>    <span class="hljs-comment">//事件性质。</span>    ret = listen( listenfd, <span class="hljs-number">5</span>);    assert(ret != <span class="hljs-number">-1</span>);    epoll_event events [MAX_EVENT_NUMBER];    <span class="hljs-keyword">int</span> epollfd = epoll_create(<span class="hljs-number">5</span>);    assert(ret != <span class="hljs-number">-1</span>);    addfd(epollfd,listenfd,<span class="hljs-literal">true</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        <span class="hljs-keyword">int</span> ret = epoll_wait( epollfd, events, MAX_HANDLE_SZ, <span class="hljs-number">-1</span>); <span class="hljs-comment">//这里的-1设置成了阻塞，如果没有就绪事件将会一直阻塞</span>        <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure]\n&quot;</span>);            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">//水平触发</span>        lt(events,ret,epollfd,listenfd);        <span class="hljs-comment">//边缘触发</span>        <span class="hljs-comment">//et(events,ret,epollfd,listenfd);</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="accpet-问题"><a href="#accpet-问题" class="headerlink" title="accpet 问题"></a>accpet 问题</h3><h4 id="如果accpet的监听文件描述符阻塞"><a href="#如果accpet的监听文件描述符阻塞" class="headerlink" title="如果accpet的监听文件描述符阻塞"></a>如果accpet的监听文件描述符阻塞</h4><p>这里需要提到的是<code>accpet</code>的问题，见Linux高性能服务器开发p80页所提到的，<code>accpet</code>只是从监听队列中取出连接，而无论连接处于何种状态。在上面列举的代码中，可以清楚的看见虽然连接已经断开，但是TCP队列里面依然有这个套接字</p><p>需要注意的是，<code>RST复位键</code>却可以将已经完成的连接<strong>驱逐</strong>出TCP连接(UNP16.6章)，这样会出现一个定时问题。如果客户端先发送一个读写事件，然后监听事件就绪，acppet可以调用一个已经完成的连接，返回一个套接字。但是在此时，如果客户端发送了一个RST，就会导致accpet里面的连接被删除，这样由于监听事件还是过了if语句的，但是accpet里面却没有可以用的连接，这样会导致accpet阻塞，之后的操作将无法继续，直到有新的连接。所以需要吧<strong>监听事件设置为非阻塞</strong>。</p><h4 id="监听描述符ET模式下accpet存在的问题"><a href="#监听描述符ET模式下accpet存在的问题" class="headerlink" title="监听描述符ET模式下accpet存在的问题"></a>监听描述符ET模式下accpet存在的问题</h4><p><code>accpet</code>还有一个问题，如果同时有多个连接到达，但是监听事件只触发一次，<code>accpet</code>也只触发一次，那么就会导致之后的连接无法被加入到<code>epoll</code>之中去,虽然<code>accpet</code>仍然有连接，但是只能通过之后的连接来触发监听事件的就绪，才能继续调用<code>accpet</code>，造成效率上的问题，也可能导致连接无法继续，所以要用<code>while</code>将连接的事件全部返回。</p><p>这是只有ET模式下才会出现的问题，如果是LT模式下<code>acppet</code>还有事件可读，就会成为就绪事件被继续读取（所以改为LT模式应该也可以）</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>限于篇幅（嗯，我懒），主要<a href="https://www.cnblogs.com/l2017/p/10830391.html">参考</a>这个大佬的，将的很详细（很多都看不明白），<del>我后续如果有时间可以细看</del></p><p>源码不会骗人</p><p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/U0%5BSGUOMKP%5BSNRA00V_A@AS.png" alt="img"></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://blog.chinaunix.net/uid-28541347-id-4273856.html">http://blog.chinaunix.net/uid-28541347-id-4273856.html</a></p><p><a href="https://www.cnblogs.com/tianzeng/p/9997432.html">https://www.cnblogs.com/tianzeng/p/9997432.html</a></p><p><a href="https://www.cnblogs.com/l2017/p/10830391.html">https://www.cnblogs.com/l2017/p/10830391.html</a></p><p><a href="https://www.zhihu.com/question/39792257">https://www.zhihu.com/question/39792257</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步/异步，阻塞/非阻塞</title>
    <link href="/WennyAhhh.github.io/2020/12/08/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%20%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <url>/WennyAhhh.github.io/2020/12/08/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%20%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="同步-异步，阻塞-非阻塞"><a href="#同步-异步，阻塞-非阻塞" class="headerlink" title="同步/异步，阻塞/非阻塞"></a>同步/异步，阻塞/非阻塞</h1><blockquote><p>最近在学习Linux网络编程的时候遇到了IO模型，对于同步IO，异步IO，同步，异步，阻塞，非阻塞等这些术语，感到其定义十分模糊。尤其是抛出–epoll是同步还是异步？阻塞还是非阻塞?这个问题后，我翻阅了网上很多博主的博文，答案有些不一样，愈发感到晦涩难懂。在困扰了一个晚上外加一个上午后，才发现我已经走向死胡同了，每个答主所说的层次并不一样。</p><p>对于这些概念来说，除了应付面试，一无是处（逃，好像我不是一无是处一样</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前就已经听闻了这几个名词的大名，去知乎上逛了一圈，满心欢喜地以为自己会了。知道最近在学习IO复用，再回头审视这些概念，才明白其中的内容并没有那么简单。</p><p>参考知乎两位大佬的两篇文章<a href="https://www.zhihu.com/question/19732473/answer/117012135">（一）</a><a href="https://www.zhihu.com/question/19732473/answer/88599695">（二）</a>。我们应该站在<strong>不同的层面</strong>上看待这些问题。可以粗略分为<strong>应用级别同步/异步</strong>,<strong>操作系统同步/异步</strong>。应用级别的同步异步是基于操作系统的，比如Nginx是异步非阻塞，但是是基于epoll（操作系统层次）的同步非阻塞（非阻塞不一定，后续再说）。</p><p>需要注意一点。在异步编程中，会提起同步/异步，这一般就是上述中一般的同步/异步，但是这与<strong>IO模型</strong>中的同步异步是<strong>完全不同</strong>的概念。由于站在不同的层面上，可以提到的东西就太多了，同步IO，异步IO，同步，异步，回调，阻塞，非阻塞，并行，并发，多线程，牵扯到了进程，线程，协程，其中线程还包括三种概念：内核线程，轻量级进程（LWP），用户线程，再往深处，Linux对于进程/线程的处理。（我一开始写的时候没有打算写那么多，然后写的时候发现与这些概念都混淆了，虽然有些东西很早之前就理解了，但是出现一个新知识的时候，才发现需要理解的不够。）</p><p>本文只涉及IO模型和进程间通信的相关内容。</p><p>本人没有野心把这种繁杂的概念一一理清，毕竟这些概念除了和面试官聊（chui）得（niu）开（pi）以外，对于代码提升没有什么帮助。</p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>在学习计算机组成原理的时候，提到过DMA的工作方式 </p><p>​                         <img src="https://i.loli.net/2020/12/07/E4WKLQxe81qnVOD.png"></p><p>由于主存和DMA接口之间有一条数据通路，因此主存和设备交换信息时，不通过CPU，也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复线程，因此工作速度比程序中断的工作速度高。具体的内容可以参考《计算机组成原理》，有更加详细的解释。</p><p>在这里需要指出的是，DMA对于CPU来说，只有传输开始和结束的时候需要发出中断指令，其他的时间都不需要CPU参与。所以是异步非阻塞。异步体现在IO的回调，是CPU被动的，非阻塞体现在CPU依然在运行其他程序。</p><h2 id="应用级别"><a href="#应用级别" class="headerlink" title="应用级别"></a>应用级别</h2><blockquote><p>对于同步异步来说，是对应<strong>两个或多个关系</strong>的。</p><ul><li><p>同步操作时，调用者需要等待被调用者返回结果，才会进行下一步操作</p></li><li><p>异步则相反，调用者不需要等待被调用者返回调用，即可进行下一步操作，被调用者通常依靠事件、回调等机制来通知调用者结果。</p></li></ul><p>对于阻塞和非阻塞来说，是<strong>当前进程的状态</strong>。</p><ul><li><p>阻塞就是当前进程被挂起，暂时放弃CPU，直到调用线程调用完毕，并返回结果和状态。</p></li><li><p>非阻塞是不能立刻得到结果之前，该调用者不会阻塞当前进程。而是直接返回状态。</p></li></ul></blockquote><p>通俗一点来说，可以参考知乎上的“<a href="https://www.zhihu.com/question/19732473/answer/23434554">水壶模型</a>”(嗯，我懒得写了)。</p><p>需要注意的是，这两个概念并非完全是是毫不相干的，因为异步会执行下一个任务，那么就必不可能阻塞。同理，同步也不会非阻塞而放弃等待返回值。关于异步处理的流程需要参照各种框架。比方说python的协程（同步阻塞），nginx（异步非阻塞）。</p><p>但是有些框架，比如Node.js都是异步的，如果需要同步，那么就需要异步阻塞。</p><p>对于轮询操作，是同步非阻塞的。</p><p>当然，也有大佬提出：进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词。</p><p>同步异步模型也可以放入操作系统级别之中，虽然我认为这个套用毫无意义。</p><h2 id="线程层次"><a href="#线程层次" class="headerlink" title="线程层次"></a>线程层次</h2><p>Stevens大神在UNP中提到了<strong>五种IO模型</strong>。(IO应该要打成I/O)</p><ul><li><strong>阻塞式IO</strong></li><li><strong>非阻塞式IO</strong></li><li><strong>IO复用</strong>（select，poll, epoll,其中epoll是后面出来的，没有写入UNP中。）</li><li><strong>信号驱动式IO</strong>(SIGIO)</li><li><strong>异步IO</strong></li></ul><p>其中前面四种都是<strong>同步IO</strong>,最后一种才是<strong>异步IO</strong>。暂且抛开同步异步，阻塞非阻塞的隔阂，什么是<strong>IO操作</strong>?一个输入操作通常包括两个不同阶段</p><ol><li><p>等待数据准备好，就绪</p></li><li><p>从内核缓冲区向进程复制数据</p></li></ol><p>严格来说，如果发起recv请求，第一步并没有准备好，那么这个等待的过程就是阻塞，线程挂起，因为这个时间段是不需要消耗CPU的。</p><p>但是，如果当前是二阶段，且是同步IO，那么用recv从内核缓存读取线程就不能算作阻塞。如果对这些理解不是很明白，可以先略过，回头再看。</p><p>在理解这些概念的时候不要将应用级别的同步异步带入到这里，因为是不同级别的概念，也不要试图去找共同点，找到的只是你认为的共同点而已，没有意义。</p><h3 id="阻塞式IO模型"><a href="#阻塞式IO模型" class="headerlink" title="阻塞式IO模型"></a>阻塞式IO模型</h3><p>最流行的IO模型就是阻塞式IO模型。在默认情况下，所有的套接字都是阻塞的。</p><p>当我们调用recv读取数据，如果数据没有，那么从无数据准备好到有数据准备好（第一步），是个阻塞的过程。</p><p>数据存在了之后，由recv复制到用户空间。</p><p><img src="https://static.oschina.net/uploads/img/201604/20150405_VKYH.png" alt="输入图片说明"></p><p>数据只能在recv读入完成之后才返回。</p><p>第一阶段同步阻塞</p><h3 id="非阻塞式IO模型"><a href="#非阻塞式IO模型" class="headerlink" title="非阻塞式IO模型"></a>非阻塞式IO模型</h3><p>进程把一个套接字设置成非阻塞，在recv的时候，如果需要等待第一步，非阻塞就直接返回一个错误。可以循环发起recv请求，如下图。直到第四次调用有数据了，才会被复制到进程缓冲区。</p><img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/20152818_DXcj.png"/><p>当对一个<strong>非阻塞描述符</strong>循环调用recv时，称之为<strong>轮询</strong>。</p><p>第一阶段同步非阻塞</p><p>在看到很多博文，在关于select中说到这个轮询。这其实是错误的，虽然这个名字很好听。应该叫做遍历更为恰当（当然是我自己的想法）</p><h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>IO复用有select，poll和epoll，会着重讲解用的比较多的epoll 。</p><p>利用IO复用，就可以阻塞在IO复用之上，而不是阻塞在真正的IO系统调用之上（不讲人话</p><p>其实就是在第一阶段和第二阶段分开，让文件描述符阻塞在IO复用上，其中IO复用可能有多个文件描述符。我们阻塞IO复用，等待数据报套接字变为可读，然后返回套接字可读（也就是第一阶段完成，成为就绪事件）， 就调用recv进行第二阶段。</p><p>​                          <img src="https://cdn.jsdelivr.net/gh/WennyAhhh/image@master/img/DQ@HGRK%5BWZ%5D5%60L%7DWW%7BM@6DW.png"></p><p>这里很简单地介绍一下几个IO复用，以后有机会补上（咕咕咕</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>​    在第一阶段完成后 select中包含了就绪事件，但是并不保证所有的事件都是就绪事件，所有需要遍历，时间复杂度为O（N）。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>​    虽然比select能有更多的事件处理类型，但是依然存在O(N)的问题。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>​    由于都是调用函数返回的，第一阶段是同步的，至于是不是非阻塞，如果timeout=0那么是非阻塞，如果timeout&gt;0那么会阻塞一段时间，-1为一直阻塞</p><h3 id="信号驱动式IO模型"><a href="#信号驱动式IO模型" class="headerlink" title="信号驱动式IO模型"></a>信号驱动式IO模型</h3><p>这个模型用的少，其实还是很值得讨论的。可惜没人待见，少了热度，像极了人生</p><p>利用信号，让内核在描述符就绪时发送SIGIO信号通知。如下图，通过建立SIGIO信号处理程序，建立完立刻返回，进程继续工作，也不需要进行轮询。等到第一阶段完成，发送一个SIGIO信号给信号处理程序，然后调用recv读出数据。</p><p>​                          <img src="https://pic4.zhimg.com/80/6294fb7f7f5c22e39187a490c35ac6f0_720w.jpg?source=1940ef5c" alt="img"></p><p>最大的好处是在于等待数据包达到期间进程不被阻塞，主循环可以继续执行，只要等待信号处理函数的通知就可以了。</p><p>由于返回的通知是回调，并且进程未阻塞，所以应该是第一阶段是异步非阻塞模型。</p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>和信号驱动IO很像，但是区别在于信号驱动IO只能用信号通知用户已经准备完成，然后启动第二阶段，但是异步IO是将第二阶段也交给了内核处理，返回一个信号。</p><p>​                    <img src="https://static.oschina.net/uploads/img/201604/20175459_gtgw.png" alt="输入图片说明"></p><p>Linux有AIO库，调用aio_read()函数，给内核传递描述符，缓冲区（需要告诉用户缓冲区的位置），缓冲大小，文件偏移（如果有多个线程同时写？）,并设置一个回调函数。用户进程在调用AIO时直接返回，进程不阻塞。</p><p>由此来看同步IO在第二个阶段由于都是函数返回，且有数据，所以是同步非阻塞模型</p><p>对于异步IO来说，两个阶段是一起的，异步非阻塞模型。</p><h3 id="同步IO与异步IO"><a href="#同步IO与异步IO" class="headerlink" title="同步IO与异步IO"></a>同步IO与异步IO</h3><p>POSIX把这两个术语定义如下：</p><ul><li><strong>同步IO操作</strong> 导致请求进程阻塞，直到IO操作完成</li><li><strong>异步IO操作</strong> 不导致请求进程阻塞</li></ul><p>什么是请求进程？recv就是。对于一个文件描述符设置为非阻塞，只有在没有数据就绪的时候，会直接返回。如果有数据，那么文件描述符阻塞不阻塞都无所谓，都需要从内核缓冲区写入到用户缓冲区，此时，上述四种都是阻塞的，直到IO操作。所以前四种都是同步IO。</p><p>只有异步IO，在其中调用了AIO，在内核中写入数据，请求进程直接返回，才符合异步IO的定义。</p><p>在IO时间中，同步和异步区分的是内核向应用程序通知的是何种IO事件（是就绪时间还是完成事件），以及该由谁来完成IO读写（是应用程序还是内核）</p><p>一言蔽之，第二个阶段是谁完成的。如果是内核完成的，那么就是异步IO，如果是用户完成的，那么就是同步IO。</p>]]></content>
    
    
    <categories>
      
      <category>Linux网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 493.翻转对</title>
    <link href="/WennyAhhh.github.io/2020/11/29/LeetCode%20493.%E7%BF%BB%E8%BD%AC%E5%AF%B9/"/>
    <url>/WennyAhhh.github.io/2020/11/29/LeetCode%20493.%E7%BF%BB%E8%BD%AC%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-493-翻转对"><a href="#LeetCode-493-翻转对" class="headerlink" title="LeetCode 493.翻转对"></a>LeetCode 493.翻转对</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>原题<a href="https://leetcode-cn.com/problems/reverse-pairs/">链接</a></p><blockquote><blockquote><p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p></blockquote><p>你需要返回给定数组中的重要翻转对的数量。</p><p>示例 1:</p><p>输入: [1,3,2,3,1]<br>输出: 2</p><p>示例 2:</p><p>输入: [2,4,3,5,1]<br>输出: 3</p><p>注意:</p><p>​    给定数组的长度不会超过50000。<br>​    输入数组中的所有数字都在32位整数的表示范围内。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>输入: [1,3,2,3,1]<br>输出: 2</p></blockquote><table><thead><tr><th>res1: 1 3 2 3 1 （依据题意每个*2</th></tr></thead><tbody><tr><td>res2: 2 6 4 6 2</td></tr></tbody></table><p>这道题目就变成了，给定一个位置pos，res2[pos-n] 比 res1[pos]大的值的数量</p><p>那么朴素的思路就是，建一个哈希表，然后从后往前遍历，对于每个res1[i],只需要遍历哈希表，找出比res1[i]小的个数，记录下来，然后在哈希表中存入res2[i]。</p><p>首先，数的大小范围是32位整数，包括负数，导致自己创造哈希表需要加上一个偏移量，还有数组过大的问题。×2还会导致整数溢出。</p><p>每次都要遍历一次哈希表，时间复杂度过高。如果使用前缀和，会导致插入操作的时间复杂度为O(n);</p><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>可以使用一个<code>unordered_map</code>进行离散化数据。由于需要比较的是两个数组的所有值，所以需要吧两个数组合在一起，排序，编号。</p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>线段树是用于求前缀和，插入的时间复杂度是O(logN),求前缀和的时间复杂是O(logN)。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> n=<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> fa[<span class="hljs-number">100010</span>];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;        <span class="hljs-keyword">return</span> x&amp;-x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)&#123;            res+=fa[x];            x-=lowbit(x);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> k)</span></span>&#123;        <span class="hljs-keyword">while</span>(x&lt;=n)&#123;            fa[x]+=k;            x+=lowbit(x);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-comment">//前缀和和树状数组</span>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; tem;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; e:nums)&#123;            tem.push_back(e);            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k=e;            tem.push_back(k*<span class="hljs-number">2</span>);        &#125;        sort(tem.begin(),tem.end());        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>,<span class="hljs-keyword">int</span>&gt; res;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; e:tem)&#123;            res[e]=n++;        &#125;        <span class="hljs-keyword">int</span> m=nums.size();        <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)nums[i]*<span class="hljs-number">2</span>;            cur+=ask(res[nums[i]]<span class="hljs-number">-1</span>);            update(res[k],<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> cur;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条款38 has-a 条款39 明智而审慎地使用private继承</title>
    <link href="/WennyAhhh.github.io/2020/11/07/%E6%9D%A1%E6%AC%BE38%20has-a%20%E6%9D%A1%E6%AC%BE39%20%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF/"/>
    <url>/WennyAhhh.github.io/2020/11/07/%E6%9D%A1%E6%AC%BE38%20has-a%20%E6%9D%A1%E6%AC%BE39%20%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="条款38-has-a-条款39-明智而审慎地使用private继承"><a href="#条款38-has-a-条款39-明智而审慎地使用private继承" class="headerlink" title="条款38 has-a 条款39 明智而审慎地使用private继承"></a>条款38 has-a 条款39 明智而审慎地使用private继承</h1><hr><p><code>public</code>继承都有 一种<code>is-a</code>的意义，在UML中还存在一种<code>has-a</code>的关系，对应的</p><h2 id="private继承"><a href="#private继承" class="headerlink" title="private继承"></a>private继承</h2><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span>..&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span> <span class="hljs-keyword">private</span> Person&#123;...&#125;;Person p;Student s;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Person&amp; p)</span></span>;eat(p); <span class="hljs-comment">//正确</span>eat(s); <span class="hljs-comment">//错误 </span></code></pre><p>不同于<code>public</code>继承，经过实测，编译器都不会自动将<code>private</code>继承和<code>protected</code>继承转化为<code>derived class</code>对象，并且，<code>base class</code>中的成员在<code>derived class</code>都将成为<code>private</code>成员，无论之前是<code>public</code>或者<code>protected</code>。</p><p>当我们需要一些工具放在我们的clas中时，并且这个工具类中有<code>virtual</code>函数，我们需要通过继承来重新定义这个工具类。<code>is-a</code>意义的<code>public</code>继承不是一个好选择，所以我们采用<code>private</code>继承</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tickFrequency)</span></span>&#123;&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span><span class="hljs-keyword">private</span> Timer&#123;<span class="hljs-keyword">private</span>:    <span class="hljs-comment">//private防止客户误用接口</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;&#125;</code></pre><h2 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h2><p><code>private</code>继承在有些场合是没有必要的，完全可以使用复合对象（条款38）来完成</p><pre><code class="hljs cpp"><span class="hljs-comment">//WidgetTimer.h</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidigetTimer</span>:</span><span class="hljs-keyword">public</span> Timer&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;&#125;<span class="hljs-comment">//WidgetTimer.cpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Timer&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WidgetTimer::onTick</span><span class="hljs-params">()</span></span>&#123;    ...&#125;<span class="hljs-comment">//Widget.h</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetTimer</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>&#123;</span><span class="hljs-keyword">private</span>:    WidgetTimer timer;&#125;</code></pre><p>上例采用了复合，WidgetTimer is a Timer 并没有什么问题，并且为尽量减少编译依存度，不采用内部类，而是分离出来。<br>有一种激进的情况，空间最优化。如上例，在内部创建一个类总是需要空间的，而我需要使用的工具类中不带有任何数据，<code>non-static</code>成员变量,<code>virtual</code>函数,<code>virtual base classes</code>，总之，实例化后占用空间为0的类，可以使用private继承空间最优化。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条款37 绝不重新定义继承而来的缺省参数</title>
    <link href="/WennyAhhh.github.io/2020/11/05/%E6%9D%A1%E6%AC%BE37%20%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0/"/>
    <url>/WennyAhhh.github.io/2020/11/05/%E6%9D%A1%E6%AC%BE37%20%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="条款37-绝不重新定义继承而来的缺省参数"><a href="#条款37-绝不重新定义继承而来的缺省参数" class="headerlink" title="条款37 绝不重新定义继承而来的缺省参数"></a>条款37 绝不重新定义继承而来的缺省参数</h1><h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p>//学C++总感觉有些东西刚开始只能意会，反复琢磨才能区分。</p><p>参考<a href="https://www.cnblogs.com/lizhenghn/p/3657717.html">blog</a></p><p><strong>静态类型</strong>：对象在声明时采用的类型，在<strong>编译期</strong>既已确定；</p><p><code>int a=2;</code></p><p><strong>动态类型</strong>：通常是指一个指针或引用目前所指对象的类型，是在<strong>运行期</strong>决定的；</p><p><code>Shape* pc=new Circle  //ps的静态类型为Shape* 但是他的动态类型是Circle*,在运行期间给的</code></p><p><strong>静态绑定</strong>：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在<strong>编译期</strong>；</p><p><code>int a=2;  //对缺省参数值是动态绑定</code></p><p><strong>动态绑定</strong>：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在<strong>运行期</strong>；</p><p>``Shape* pc=new Circle //ps对Circle是动态绑定`</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>其实也是比较玄学下面看个例子（Effective C++抄的)</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">enum</span> ShapeColor &#123;Red,Green,Blue&#125;;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> :</span><span class="hljs-keyword">public</span> Shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Green)</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Rectangle: &quot;</span>&lt;&lt;color &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> :</span> <span class="hljs-keyword">public</span> Shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color)</span><span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Circle: &quot;</span>&lt;&lt;color &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;Shape* ps;<span class="hljs-comment">//ps只有静态类型</span>Shape* pr = <span class="hljs-keyword">new</span> Rectangle(); <span class="hljs-comment">//pr的静态类型为Shape* ，动态类型为Rectangle* 。是动态绑定，下同</span>Shape* pc = <span class="hljs-keyword">new</span> Circle();Rectangle* c = <span class="hljs-keyword">new</span> Rectangle();c-&gt;draw();pr-&gt;draw();pc-&gt;draw();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>​    运行结果</p><pre><code class="hljs cpp">Rectangle: <span class="hljs-number">1</span><span class="hljs-comment">//Green</span>Rectangle: <span class="hljs-number">0</span><span class="hljs-comment">//Red</span>Circle: <span class="hljs-number">0</span><span class="hljs-comment">//Red</span></code></pre><p>对于第一行结果，我们没有什么惊讶的。但是对于第二行，我们明明在<code>derived</code>中重新设置了缺省值，所以运行的应该也是<code>Green</code>，但是编译器和我们想的不一样。对于虚函数来说，是动态绑定的，<code>pr</code>绑定的是<code>derived</code>，所以在运行时调用的是<code>Rectangle</code>的<code>draw</code>。由于的<code>pr</code>的静态类型是<code>Shape*</code>，所以此调用的缺省值都是来自<code>Shape</code>的。</p><p>至于为什么<code>pr</code>不使用<code>Rectangle</code>静态绑定的缺省值,也就是<code>Green</code>。因为C++的性能压榨，对于<code>pr</code>来说，在编译期就已经确定好了静态类型<code>Shaped</code>，而其中的<code>draw</code>是动态类型，所以要在运行期才能绑定。那么为了效率，在编译期间就把缺省值固定住，机制更加简单,性能更好。</p><h2 id="NVI手法"><a href="#NVI手法" class="headerlink" title="NVI手法"></a>NVI手法</h2><p>综上所述，我们不应该在在<code>derived</code>中重新定义缺省值，但是在上述例子中</p><p><code>void draw(ShapeColor color) const;</code></p><p>当使用多态的时候，很好没有问题，他会继承base而来的缺省值，但是如果单独调用的话，也就是</p><p><code>Circle* pc=new Circle</code>注意，这里并没有继承base而来的缺省值，他<strong>什么都没有</strong>，需要用户指定。所以我们在使用有缺省值的<code>virtual</code>函数的时候，应该是这样的</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">enum</span> ShapeColor &#123;Red,Green,Blue&#125;;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-keyword">const</span></span>=<span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> :</span><span class="hljs-keyword">public</span> Shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Rectangle: &quot;</span>&lt;&lt;color &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;</code></pre><p>如果你面向对象的思维已经深入骨髓的话，你会嗤之以鼻：</p><p>1.代码重复，重复了<code>= Red</code><del>欲加之罪何患无辞</del></p><p>2.增加了<code>base</code>和<code>derived</code>的依存度，如果<code>base</code>需要修改的话，所有的<code>derived</code>也需要修改</p><p>其实这就是条款35，考虑<code>virtual</code>函数以外的其他选择，其中包含了 NVI（no-virtual interface），策略模式（函数指针和function）</p><p>对于客户端来说，策略模式需要知道其内部的实现，也就是 传递一个函数或者类。如果我都需要传递一个函数了，那么缺省值就直接设置，没有什么讨论的意义了，所以我们采用NVI的方法实现</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">enum</span> ShapeColor &#123;Red,Green,Blue&#125;;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color=Red)</span></span>&#123;        ...        dodraw();        ...    &#125;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-keyword">const</span></span>=<span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> :</span><span class="hljs-keyword">public</span> Shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Rectangle: &quot;</span>&lt;&lt;color &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;</code></pre><p>这样，把缺省值放在了<code>no-virtual</code>中，由于在第36条款中描述的，绝不重新定义继承而来的<code>no-virtual</code>函数，所以缺省值是不会被<code>derived class</code>覆写。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程学习(三).md</title>
    <link href="/WennyAhhh.github.io/2020/10/28/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%89/"/>
    <url>/WennyAhhh.github.io/2020/10/28/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C-多线程学习-三"><a href="#C-多线程学习-三" class="headerlink" title="C++多线程学习(三)"></a>C++多线程学习(三)</h1><p>等待时间或其他条件</p><p>（本来都打完了，然后切了后台，全没了（哭腔）</p><p>如果一个线程需要另外一个线程完成才能继续，例如队列，pop()的前提是empyt()为false，所以需要一个线程进行push操作，才能进行pop操作。</p><p>c++标准库提供了<code>std::condition_variable</code>和<code>std::condition_variable_any</code>，头文件在<code>&lt;condition_variable&gt;</code></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;condition_variable&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">threadsafe_queue</span> &#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-built_in">std</span>::mutex mut;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;T&gt; data_queue;    <span class="hljs-comment">//condition_variable只限于对mutex进行工作.condition_cariable_any可以是任意的，例如bool。常用前者</span><span class="hljs-built_in">std</span>::condition_variable data_cond;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span> </span>&#123;<span class="hljs-comment">//入队列，然后notify消息</span><span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;data_queue.push(new_value);        <span class="hljs-comment">//由于这里  notify是一对一的，因为push只有一个对象。他会在wait中只唤醒一个。</span>        <span class="hljs-comment">//如果是一对多的情况，就需要使用 notify_any()</span>data_cond.notify_one();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;        <span class="hljs-comment">//这里需要使用灵活的unique_lock，原因在于。如果wait返回的是false，那么就会解锁并进入阻塞状态</span>        <span class="hljs-comment">//如果另外一个线程调用了notify(),那么他会被唤醒，解除阻塞，并获取锁（加锁）。然后再次检测其函数，如果</span>        <span class="hljs-comment">//返回的是true,那么就继续下去，反之解锁，进入阻塞态，这样就造成了虚假唤醒</span>data_cond.wait(lk, [<span class="hljs-keyword">this</span>] &#123;<span class="hljs-keyword">return</span> !data_queue.empty();&#125;);value = data_queue.front();data_queue.pop();&#125;&#125;;threadsafe_queue&lt;<span class="hljs-keyword">int</span>&gt; data_queue;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">data_preatation_thread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;data_queue.push(i);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">data_processing_thread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">int</span> value=<span class="hljs-number">0</span>;data_queue.wait_and_pop(value);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">if</span> (i%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> x, y;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y;<span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">my1_thread</span><span class="hljs-params">(data_preatation_thread,x)</span></span>;<span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">my2_thread</span><span class="hljs-params">(data_processing_thread,y)</span></span>;        <span class="hljs-comment">//join别忘了！！</span>my1_thread.join();my2_thread.join();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-C++并发编程学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条款21 reference返回需要谨慎</title>
    <link href="/WennyAhhh.github.io/2020/10/19/%E6%9D%A1%E6%AC%BE21%20reference%E8%BF%94%E5%9B%9E%E9%9C%80%E8%A6%81%E8%B0%A8%E6%85%8E/"/>
    <url>/WennyAhhh.github.io/2020/10/19/%E6%9D%A1%E6%AC%BE21%20reference%E8%BF%94%E5%9B%9E%E9%9C%80%E8%A6%81%E8%B0%A8%E6%85%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="条款21-reference返回需要谨慎"><a href="#条款21-reference返回需要谨慎" class="headerlink" title="条款21 reference返回需要谨慎"></a>条款21 reference返回需要谨慎</h1><p>返回的对象如果是创建在栈中的，比如</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Ration&amp; lhs,<span class="hljs-keyword">const</span> Ration&amp; rhs)&#123;<span class="hljs-function">Ration <span class="hljs-title">result</span><span class="hljs-params">(...)</span></span>;<span class="hljs-comment">//构造函数，懒得写参数了。。。</span>.....<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">//客户端调用</span><span class="hljs-function">Ration <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<span class="hljs-function">Ration <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>;Ration res=a*b;<span class="hljs-comment">//是错误的</span></code></pre><p>以上代码会发生致命错误：在栈上实例化，在跳出作用域的时候调用析构函数，导致返回一个空引用。</p><p>如果在堆上创建，并且返回一个引用（当然不可能返回一个实例，如果返回一个实例的话就没地方delete）</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> Ration&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Ration&amp; lhs,<span class="hljs-keyword">const</span> Ration&amp; rhs)&#123;Ration *result=<span class="hljs-keyword">new</span> Ration(...);<span class="hljs-keyword">return</span> *result;&#125;</code></pre><p>这样会导致一个错误，内存泄漏。很容易会忘记delete，就算很小心翼翼，也会在不经意间出错</p><pre><code class="hljs cpp">Ration res=a*b*c;<span class="hljs-comment">//中间结果没有delete</span></code></pre><p>如果采用<code>static</code>,如果清楚全局变量，就会理解这种错误</p><pre><code class="hljs `cpp">const Ration&amp; operator*(const Ration&amp; lhs,const Ration&amp; rhs)&#123;static Ration result(....);...return result;&#125;&#x2F;&#x2F;这样由返回的是引用，所以&#x3D;&#x3D;前后返回的都是“现值”，也就是说 这个if语句只会返回true；if((a*b)&#x3D;&#x3D;(c*d))&#123;&#125;</code></pre><p>所以，不要盲目返回reference，还是使用by-value吧。在C++11中，有了move和forward，可以解决调用拷贝函数和析构函数的烦恼。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条款20，用引用取代传值</title>
    <link href="/WennyAhhh.github.io/2020/10/19/%E6%9D%A1%E6%AC%BE20%EF%BC%8C%E7%94%A8%E5%BC%95%E7%94%A8%E5%8F%96%E4%BB%A3%E4%BC%A0%E5%80%BC/"/>
    <url>/WennyAhhh.github.io/2020/10/19/%E6%9D%A1%E6%AC%BE20%EF%BC%8C%E7%94%A8%E5%BC%95%E7%94%A8%E5%8F%96%E4%BB%A3%E4%BC%A0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="条款20，用引用取代传值"><a href="#条款20，用引用取代传值" class="headerlink" title="条款20，用引用取代传值"></a>条款20，用引用取代传值</h1><p>在默认情况下，对一个函数传值是实际参数的副本为初值，也就是说在函数中的修改只是 修改了其副本。<br>但是调用<code>cpoy</code>操作可能是一项昂贵的动作</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><span class="hljs-keyword">public</span>:Person();<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-keyword">virtual</span> ~Person();<span class="hljs-keyword">private</span>:<span class="hljs-built_in">string</span> name;<span class="hljs-built_in">string</span> address;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Studennt</span>:</span> <span class="hljs-keyword">public</span> Person&#123;<span class="hljs-keyword">public</span>:Student();~Student();getResult();<span class="hljs-keyword">private</span>:<span class="hljs-built_in">string</span> schoolName;<span class="hljs-built_in">string</span> schoolAddress;&#125;</code></pre><p>如果调用<code>bool validateStudent(Student s);</code>首先Student的copy函数会先调用，然后调用两个string的构造函数。copy完成之后，需要调用两个string的析构函数，然后再调用Student的析构函数。类似的，由于存在继承关系，Perso也 需要调用一次构造函数，一个析构函数，两次string的构造函数，两次string的析构函数。</p><p>并且需要 注意的是<code>virtual getResult();</code>函数。这是一个虚函数，由于 多态的存在，当我们调用参数是<code>Person</code>时，我们期望函数中的<code>Person s</code>继承了<code>Student</code>的性质。但是可惜的是，由于copy不管这些，所以还是<code>Person</code>的<code>getResult()</code>,    产生了<strong>对象切割</strong></p><p><strong>代价是昂贵的</strong></p><p>我们可以采用C++的引用解决这些问题。但是需要注意的是传值操作不会改变原有的数据，所以在调用时，我们需要这样定义</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Student&amp; s)</span></span>;</code></pre><blockquote><p>请记住：<br>    尽量以pass-by-reference-to-const替代pass-by-value。前者通常比较高效，并且可以避免切割问题。<br>    以上规则并不是适用于内置类型，已经STL的迭代器和函数对象对他们而言，pass-by-value比较适当。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零碎的笔记</title>
    <link href="/WennyAhhh.github.io/2020/10/19/%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/"/>
    <url>/WennyAhhh.github.io/2020/10/19/%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="零碎笔记"><a href="#零碎笔记" class="headerlink" title="零碎笔记"></a>零碎笔记</h1><h2 id="同步，异步，阻塞，非阻塞"><a href="#同步，异步，阻塞，非阻塞" class="headerlink" title="同步，异步，阻塞，非阻塞"></a>同步，异步，阻塞，非阻塞</h2><p>今天上课听到的一些概念。觉得挺容易混淆的，之前在学习系统编程的时候遇到这些概念，没有系统总结过，经常懵。</p><p><strong>同步和异步</strong></p><p>同步和异步是针对<strong>消息通讯机制</strong>来说的。</p><p>当发生函数调用的时候，在<strong>同步</strong>的情况，当前线程必须要等待函数调用完成，因为这个调用他不发送任何消息，如果不是死等，那么万一错过了就真的错过了。</p><p>在<strong>异步</strong>的情况下，他会在函数调用完成之后发送一个就直接返回了，返回的不是结果。实际处理这个调用的部件在完成后，通过状态，通知和回调函数来通知调用者。简单来说说是会给当前进程一个<strong>通知</strong>  (至于具体的通知形式，emm我只是搬运工</p><p><strong>阻塞和非阻塞</strong></p><p>阻塞和非阻塞是针对<strong>当前队列等待消息通知时的状态</strong>角度来说的。</p><p>当调用函数时，在阻塞状况下，当前线程会被挂起，等待函数返回。</p><p>在非阻塞的状况下，当前线程不会挂起，而会继续处理其他事情。</p><p><strong>同步阻塞/同步非阻塞/异步阻塞/异步非阻塞</strong></p><p>这其实两两组合的啦。</p><p>同步阻塞，发生调用时，当前线程挂起，一直等待调用结束然后唤起。</p><p>同步非阻塞, 发生调用时，当前线程可以去干别的事情，但是由于没有消息通知，所以要过一段时间去检测调用是否完成。</p><p>异步阻塞，发生调用时，当前线程挂起，一直等待调用结束，发了一个通知再唤醒。</p><p>异步非阻塞，发生调用时，当前线程干别的事情，当调用结束，接收到了通知，当前线程就会处理。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程学习（一）</title>
    <link href="/WennyAhhh.github.io/2020/10/12/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
    <url>/WennyAhhh.github.io/2020/10/12/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="C-多线程学习（一）"><a href="#C-多线程学习（一）" class="headerlink" title="C++多线程学习（一）"></a>C++多线程学习（一）</h1><p>C++11中加入了<thread>头文件，此头文件主要声明了std::thread线程类。C++11的标准类std::thread对线程进行了封装，定义了C++11标准中的一些表示线程的类、用于互斥访问的类与方法等。应用C++11中的std::thread便于多线程程序的移值。</p><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;do_something&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_something_else</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;do_something_else&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">background_task</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//仿函数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;do_something();do_something_else();&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;background_task f;    <span class="hljs-comment">//加入线程</span>    <span class="hljs-comment">//callable,可调用对象，将带有函数调用符类型的实例传入std::thread类中，替换默认的构造函数</span><span class="hljs-function">thread <span class="hljs-title">my_thread</span><span class="hljs-params">(f)</span></span>;    <span class="hljs-comment">//等待my_thread线程结束</span>my_thread.join();    <span class="hljs-comment">//分离线程</span>    my_thread.detach();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如果传递的是一个临时变量（右值），比如函数的返回值，编译器就会解析为函数声明，而不是我们期望的类型对象。所以在调用的时候，有三种方式</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">my_thread</span><span class="hljs-params">((background_task()))</span></span>;<span class="hljs-comment">//()包起来</span><span class="hljs-built_in">std</span>::thread my_thread&#123;background_task()&#125;;<span class="hljs-comment">//&#123;&#125;将函数名包含住</span><span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">my_thread</span><span class="hljs-params">([]&#123;<span class="hljs-comment">//lanbda表达式</span></span></span><span class="hljs-function"><span class="hljs-params">    do_something();</span></span><span class="hljs-function"><span class="hljs-params">    do_something_else();</span></span><span class="hljs-function"><span class="hljs-params">&#125;)</span></span></code></pre><p>先提一下名字：<code>父进程</code>，创建了其他进程的进程。上例来说，main是父进程。<code>子进程</code>，被父进程创建出来的进程。上例’<code>f</code>调用的仿函数为子进程，do_something和do_something_else为一个线程。</p><p>这样就完成了线程的启动工作。如果将代码中的<code>my_thread.join()</code>删除，程序可能不会正常运行。你需要明确在父线程结束前，是否要让my_thread线程加入(<code>join</code>),还是分离(<code>detach</code>)。先暂时放开这两个名词。想象</p><blockquote><p>1.如果子线程还没有运行完成，但是父线程已经销毁了，那么这个线程该去哪里？变成了孤儿线程。</p><p>2.如果子线程已经运行完成了，但是父线程还在运行或者父线程没有清理（wait）子线程，那么子线程是什么状态？僵尸进程。</p><p>3.如果线程在运行时使用了共享资源，即父线程和子线程使用了同样的资源。如果父线程销毁了资源，或者是子线程这样干了，会导致程序出错。</p></blockquote><p>所以我们需要在父线程中管理子线程。</p><h2 id="等待线程完成"><a href="#等待线程完成" class="headerlink" title="等待线程完成"></a>等待线程完成</h2><p>如果需要线程等待，需要使用<code>join()</code>。当启动线程后，在父线程中可以干自己的事，子线程也有自己的工作要做。<code>join</code>是简单粗暴的等待线程完成或不等待。当你需要对等待中的线程有更灵活的控制时，比如，看一下某个线程是否结束，或者只等待一段时间（超过一段时间就判定为超时)。</p><p><code>join</code>还清理了线程相关的储存部分(调用了wait来清理以结束的子进程)，避免出现僵尸进程。这样对象将不再与已经完成的线程有任何关联。所以对一个线程只能使用一次<code>join()</code>,可以用<code>joinable()</code>返回的布尔值判断是否已经调用了<code>join</code>。</p><p>就想锁和new一样，这样两两对应操作总是不友好的操作。可能在运行到一半时返回异常，也可能忘记了。所以完全可以使用<code>RAII</code>的内存管理方式解决这个问题（在智能指针的博文中我有详细的介绍）</p><pre><code class="hljs cpp"><span class="hljs-comment">//防止调用拷贝函数，私有继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Uncopyable</span> &#123;</span><span class="hljs-keyword">protected</span>:Uncopyable() &#123;&#125;~Uncopyable() &#123;&#125;<span class="hljs-keyword">private</span>:Uncopyable(<span class="hljs-keyword">const</span> Uncopyable&amp;);Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Uncopyable&amp;);&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thread_guard</span> :</span> <span class="hljs-keyword">private</span> Uncopyable&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">std</span>::thread&amp; t;<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread_guard</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::thread&amp; t_)</span> :<span class="hljs-title">t</span><span class="hljs-params">(t_)</span> </span>&#123;&#125;~thread_guard() &#123;<span class="hljs-keyword">if</span> (t.joinable()) &#123;<span class="hljs-comment">//如果还没有加入过 </span>t.join();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;调用析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;    <span class="hljs-comment">//C++ 11提供了=delete方式禁止方法调用</span>    <span class="hljs-comment">//thread_guard(thread_guard const&amp;) = delete;</span><span class="hljs-comment">//thread_guard&amp; operator=(thread_guard const&amp;) = delete;</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;background_task f;<span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(f)</span></span>;<span class="hljs-function">thread_guard <span class="hljs-title">g</span><span class="hljs-params">(t)</span></span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="转移线程所有权"><a href="#转移线程所有权" class="headerlink" title="转移线程所有权"></a>转移线程所有权</h2><p>有时候线程的所有权需要转移。</p><p>C++标准库中有很多资源（resource-owning）类型，比如<code>std::ifstream,std::unique_ptr</code>还有<code>std::thread</code>都是可移动类型，但是不可拷贝。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_other_function</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t1</span><span class="hljs-params">(some_function)</span></span>;<span class="hljs-comment">//在使用move之后，相当于资源被另外一个变量拥有了，t1会自动置为NULL</span><span class="hljs-built_in">std</span>::thread t2 = <span class="hljs-built_in">std</span>::move(t1);t1 = <span class="hljs-built_in">std</span>::thread(some_other_function);<span class="hljs-built_in">std</span>::thread t3;t3 = <span class="hljs-built_in">std</span>::move(t2);<span class="hljs-comment">//程序会崩溃</span>t1 = <span class="hljs-built_in">std</span>::move(t3);</code></pre><h2 id="运行时决定线程数量"><a href="#运行时决定线程数量" class="headerlink" title="运行时决定线程数量"></a>运行时决定线程数量</h2><p>书中提供一个例子，用多线程计算一个容器里所有类的和，例如计算<code>vector&lt;int&gt;</code>中所有整型之和。每个线程计算其中的一部分，然后全部加起来。因为不能直接从一个线程中返回一个值，所以需要传递results容器的引用到线程中去。</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator,<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">accumulate_block</span>&#123;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Iterator first, Iterator last, T&amp; result)</span> </span>&#123;<span class="hljs-comment">//从fist到last加起来再加上初始值</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;accumulate:   &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="hljs-built_in">endl</span>;result = <span class="hljs-built_in">std</span>::accumulate(first, last, result);&#125;&#125;;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator,<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">parallel_accumulate</span><span class="hljs-params">(Iterator first, Iterator last, T init)</span> </span>&#123;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">std</span>::distance(first, last);<span class="hljs-keyword">if</span> (!length) &#123;<span class="hljs-comment">//如果为0，也就是说输入范围为0</span><span class="hljs-keyword">return</span> init;&#125;<span class="hljs-comment">//设置最小的任务量</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> min_per_thread = <span class="hljs-number">25</span>;<span class="hljs-comment">//设置最大的线程数</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> max_threads = (length + min_per_thread - <span class="hljs-number">1</span>) / min_per_thread;<span class="hljs-comment">//返回这个函数能够同时并发的线程数量</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> hardware_threads = <span class="hljs-built_in">std</span>::thread::hardware_concurrency();    <span class="hljs-comment">//开几个线程</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> num_threads = min(hardware_threads != <span class="hljs-number">0</span> ? hardware_threads : <span class="hljs-number">2</span>, max_threads);    <span class="hljs-comment">//每个线程需要计算的区间大小。因为是向下取整的，所以for循环结束之后还还有一个区间需要加起来</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">const</span> block_size = length / num_threads;<span class="hljs-comment">//存放临时变量的地方</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">results</span><span class="hljs-params">(num_threads)</span></span>;<span class="hljs-comment">//开的线程都放在这边，注意要-1，因为还有一个主线程。</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; <span class="hljs-title">threads</span><span class="hljs-params">(num_threads - <span class="hljs-number">1</span>)</span></span>;Iterator block_start = first;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; (num_threads - <span class="hljs-number">1</span>); i++) &#123;Iterator block_end = block_start;        <span class="hljs-comment">//把block_end向后前进block_size个单位</span><span class="hljs-built_in">std</span>::advance(block_end, block_size);        <span class="hljs-comment">//开一个线程，记得加ref引用</span>threads[i] = <span class="hljs-built_in">std</span>::thread(accumulate_block&lt;Iterator, T&gt;(),block_start,block_end,<span class="hljs-built_in">std</span>::ref(results[i]));block_start = block_end;&#125;    <span class="hljs-comment">//把余数开个线程加起来</span>accumulate_block&lt;Iterator, T&gt;()(block_start, last, results[num_threads - <span class="hljs-number">1</span>]);<span class="hljs-built_in">std</span>::for_each(threads.begin(), threads.end(), <span class="hljs-built_in">std</span>::mem_fn(&amp;<span class="hljs-built_in">std</span>::thread::join));    <span class="hljs-comment">//把临时区间全部加起来返回</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::accumulate(results.begin(), results.end(), init);&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">21</span>,<span class="hljs-number">12</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">22</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-built_in">cout</span> &lt;&lt; parallel_accumulate&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator, <span class="hljs-keyword">int</span>&gt;(ans.begin(), ans.end(), <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : ans) &#123;sum += e;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; sum;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="识别线程"><a href="#识别线程" class="headerlink" title="识别线程"></a>识别线程</h2><p>线程标识类型是<code>std::thraed::id</code>，可以通过两种方式进行检索。</p><p>1.可以通过调用<code>std::thread</code>对象的成员函数 <code>get_id()</code>来直接获取。如果没有执行线程，就会返回<code>std::this_thread::type</code>默认构造值（个人测试出来是0)</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-string">&quot;hello&quot;</span> &#125;;<span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(f, <span class="hljs-number">3</span>, buffer)</span></span>;<span class="hljs-built_in">cout</span> &lt;&lt; t.get_id();t.join();</code></pre><p>2.当前线程中调用<code>std::this_thread::get_id()</code>也可以获得线程标识。</p><pre><code class="hljs cpp"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::this_thread::get_id();</code></pre><p>通过线程标识，可以将线程放入容器中，比如<code>std::map&lt;std::thread::id&gt;</code></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-C++并发编程学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能指针的粗浅总结</title>
    <link href="/WennyAhhh.github.io/2020/10/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%B2%97%E6%B5%85%E6%80%BB%E7%BB%93/"/>
    <url>/WennyAhhh.github.io/2020/10/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%B2%97%E6%B5%85%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="智能指针的粗浅总结"><a href="#智能指针的粗浅总结" class="headerlink" title="智能指针的粗浅总结"></a>智能指针的粗浅总结</h1><hr><p>&emsp;所谓资源就是,一旦向系统申请内存并且成功，则在使用完后还给进程。但是内存管理一直是C++麻烦的点。忘了delete,delete之后指针没有指向NULL，程序在delete之前抛出异常，对同一对象多次析构，等等痛点。我自己在学习Qt智能指针，以及之前做项目的时候遇上的内存泄露问题，使用了智能指针，但是只是知道有这个而已，没有系统总结过。对于此，查看了很多资料，略微总结了一下关于智能指针的一些用法以及原理。但是如果深究其中这篇文章是写不完的，所以只是粗略的总结一下。第一次写那么长的博文，会有一些纰漏，谅解一下。。</p><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><blockquote><p>资源取得时机便是初始化时机（Resource Acquisition Is Initialization）RAII要求，<strong>资源的有效期与持有资源的对象的生命期严格绑定</strong>，即由对象的构造函数完成资源的分配（获取），同时由析构函数完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。 –wiki</p></blockquote><p>举个简单的例子。在使用STL容器的时候定<code>vector&lt;int&gt;</code>,<code>vector&lt;int&gt;</code>只是一个变量，源代码中，他在构造函数申请了资源，又使用了析构函数释放资源。<code>res</code>是建立在栈上的，而其申请的资源是放在堆上的，利用语言机制，当<code>res</code>跳出作用域的时候，调用了析构函数，完成了内存释放。</p><p>用effective C++上的一个例子</p><pre><code class="hljs cpp"><span class="hljs-function">FontHandle <span class="hljs-title">getFont</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//工厂函数,取得资源，可以看做使用了new</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseFont</span><span class="hljs-params">(FontHandle fh)</span></span>;   <span class="hljs-comment">//释放资源，可以看做使用了delete</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Font</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span>:<span class="hljs-title">f</span><span class="hljs-params">(fh)</span></span>&#123; <span class="hljs-comment">//构造函数里面申请了资源</span>  &#125;<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123;   <span class="hljs-comment">//隐式转换函数，用于获取原始资源，方便调用</span><span class="hljs-keyword">return</span> f;&#125;~Font() &#123;releaseFont(f);<span class="hljs-comment">//析构函数释放资源</span>&#125;<span class="hljs-keyword">private</span>:FontHandle f;&#125;;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//主函数调用</span><span class="hljs-function">Font <span class="hljs-title">f</span><span class="hljs-params">(getFont())</span></span>;  <span class="hljs-comment">//由于是在栈上实例化，所以f在退出作用域的时候会调用析构函数</span><span class="hljs-keyword">int</span> newFontSize;...changFontSize(f,newFontSize);</code></pre><p>当然这只是一个例子，并没有太高的实际意义。实际中，比如多线程之中，封装 <code>Mutex </code>，构造函数加锁，析构函数解锁。这一部分我们后面会再次提到。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>利用RAII的思想，C++提供了智能指针模板，方便使用。<br>常用的智能指针针:<del>auto_ptr</del>, <code>unique_ptr, shared_ptr和weak_ptr</code>。当然Qt,boost 还提供了其他智能指针，这个留到后面细谈。 </p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>先看一段代码</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;auto&quot;</span>))</span></span>; <span class="hljs-comment">//RAII</span><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2;p2=p1;</code></pre><p>这在编译器中是可以通过的，但是<code>p1</code>会被重置为NULL。看上去很合理，因为这防止了多次析构。但是之后再次使用<code>p1</code>，可能会出现一些问题，会导致程序崩溃，这是我们不希望看见的，我们宁愿他在编译期间出错,所以我们<strong>尽量不使用auto_ptr</strong>。那么直接一点，不允许进行赋值操作，那就是<code>unique_ptr</code>。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;auto&quot;</span>))</span></span>; <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2;p2=p1; <span class="hljs-comment">//编译器会报错</span></code></pre><p><code>unique_ptr</code>虽然不允许进行赋值操作，但是凡事都有例外嘛。</p><p>1.如果<code>unique_ptr</code>是<strong>临时</strong>的右值，编译器就允许赋值。</p><pre><code class="hljs cpp"><span class="hljs-comment">//C++ primer plus中的代码</span><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">demo</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;T&quot;</span>))</span></span>;    <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; sp;ps=demo();  <span class="hljs-comment">//demo()先产生一个临时的unique_ptr&lt;string&gt; 变量，然后赋值</span></code></pre><p>2.使用<code>std::move()</code>，其实就是和<code>auto_ptr</code>一样的效果，其中右值在赋值完只有会被置为NULL</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;auto&quot;</span>))</span></span>; <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2;p2=mov(p1); <span class="hljs-comment">//p1会被置为NULL</span></code></pre><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>需求总是多种多样的，我不管我就是需要赋值操作，我的程序就是使用多个指向同一个对象的指针，那么就应该使用shared_ptr，对底层资源使用“引用计数法”，构造的时候+1，赋值的时候+1，析构的时候-1,这个资源的计数器达到0的时候调用析构函数。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;auto&quot;</span>))</span></span>; <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2;p2=p1;    <span class="hljs-comment">//此时p1不为NULL</span></code></pre><p>但是这玩意功能比较多，很容易出错。比较常见的是循环引用问题，还有一些关于多线程下的问题，放在后面一个模块。</p><p>问题代码</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FA</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FA</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">shared_ptr</span>&lt;FB&gt; b;FA()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~FA() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">shared_ptr</span>&lt;FA&gt; a;FB()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;B&#x27;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~FB() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;FA&gt; <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FA())</span></span>;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;FB&gt; <span class="hljs-title">fb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FB())</span></span>;fa-&gt;b = fb;fb-&gt;a = fa;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;fa: &quot;</span> &lt;&lt; fa.use_count() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; <span class="hljs-string">&quot;fb: &quot;</span> &lt;&lt; fb.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp">输出：     A    B    fa: <span class="hljs-number">2</span>  fb: <span class="hljs-number">2</span></code></pre><p>这里会发现，虽然使用了智能指针，但是却并没有调用其析构函数，因为这里产生了一个<strong>闭环</strong>，如果把这个环给拆了，<code>fa-&gt;b = fb;</code>或者<code>fb-&gt;a = fa;</code>删掉一个就可以了，就不展示了。</p><p>你可以把一个构造函数看做<code>&#123;</code>，把一个析构函数看做<code>&#125;</code>，shared_ptr的计数器会在析构函数中自动-1，但是没有动用析构函数，自然就不会-1。再来看这个代码，fa,fb的计数器为2就不加解释了，在fb跳出作用域的时候，fb的计数器-1，但是没有置为0，所以不会调用析构函数，自然fb中的a的计数器不会-1，此时fb的计数器为1，fa的计数器还是为2。然后fa跳出作用域，计数器-1，fa中的b计数器不为0，所以也不调用fb析构函数，也不会调用fa的析构函数。这就导致两个对象到结束，计数器都是为1的。</p><p>解决这个问题，就需要抛出另外一个智能指针weak_ptr</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr一般和shared_ptr配合使用（之前Qt尝试用QWeakPointer代替QPointer，使得QWeakPointer可以独立使用，但是后来又改回来了），用于解除循环引用。</p><p>对于上例，应该改为：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FA</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FA</span> &#123;</span><span class="hljs-keyword">public</span>:weak_ptr&lt;FB&gt; b;FA()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~FA() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~A&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span> &#123;</span><span class="hljs-keyword">public</span>:wead_ptr&lt;FA&gt; a;FB()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;B&#x27;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~FB() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;FA&gt; <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FA())</span></span>;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;FB&gt; <span class="hljs-title">fb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FB())</span></span>;fa-&gt;b = fb;fb-&gt;a = fa;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;fa: &quot;</span> &lt;&lt; fa.use_count() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; <span class="hljs-string">&quot;fb: &quot;</span> &lt;&lt; fb.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs cpp">输出：ABfa: <span class="hljs-number">1</span>  fb: <span class="hljs-number">1</span>~B~A</code></pre><p>由此可见一个事实：weak_ptr<strong>不会更改其引用计数</strong>，但是，weak_ptr并没有重载-&gt;,*操作符，如果需要使用weak_ptr封装的对象，需要调用lock()函数，这个函数会返回一个shared_ptr，但是计数器为0，就返回<code>NULL</code></p><p>而我们的任务就是在编译期间解开循环引用，但是并不保证在运行期间也不存在循环引用的问题。</p><h3 id="原始指针"><a href="#原始指针" class="headerlink" title="原始指针"></a>原始指针</h3><p>智能指针一般都提供了<strong>get()成员函数</strong>，用来执行显式转换，也就是它会返回智能指针内部的原始指针（的复件。</p><p>我们**尽量不要使用get()**，因为智能指针的初衷是将原生指针交给他来管理，get()就违背了这个初衷（试验了一下，vs2019的代码补全居然不显示get）。当然为了适配一些函数不得不去使用get，所以我们在使用get的时候需要小心。由于智能指针有些很der的操作我个人觉得在正常情况下不会有人这样去写，但是如果使用了get,在函数中，发生这样der的情况就可能出现：</p><p>1.不要使用相同的内置指针来初始化(或者reset)多个智能指针</p><p>2.不要delete get()返回的指针</p><p>3.不要用get()初始化/reset另一个智能指针</p><p>4.不要把this指针交给智能指针管理</p><p>5.不要把一个原生指针给多个shared_ptr或者unique_ptr管理</p><p>由于篇幅我原因（对，因为我懒），具体的例子我就不写了。。</p><p>如果需要调用成员函数，由于几乎所有的智能指针都重载了*，-&gt;操作符，所以直接使用把智能指针当做一般的指针变量来使用就可以了。但是有时候需要传递参数，如果参数是 T*，那么传递一个智能指针类是无法识别的。有两种方式<br>1.使用原始指针T.get()<br>2.修改函数调用参数，如果是传递一个值，那么use_count()输出是2，如果是传递指针或者引用，use_count()是1。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getResult</span><span class="hljs-params">(FA* fa)</span> </span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; fa-&gt;k &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;FA&gt; <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FA(<span class="hljs-number">1</span>))</span></span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数调用前：   &quot;</span> &lt;&lt; fa.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;getResult(fa.get());<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;函数调用后：   &quot;</span>&lt;&lt;fa.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><pre><code class="hljs cpp">输出：A函数调用前：   <span class="hljs-number">1</span><span class="hljs-number">1</span>函数调用后：   <span class="hljs-number">1</span>~A</code></pre><p>在函数传递的过程中，<strong>需要以独立语句将newed对象置入智能指针</strong>(effective C++条款17)</p><pre><code class="hljs cpp">processWidget(<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget),priority());</code></pre><p>例如上述的函数调用，第一个shared_ptr参数分为可以两个部分，并且这个顺序是固定的：</p><p>1.执行<code>new Widget</code>表达式</p><p>2.调用<code>shared_ptr</code>构造函数</p><p>但是由于会有<code>priority()</code>参数的存在，所以会产生这样的操作序列</p><p>1.执行<code>new Widget</code>表达式</p><p>2.调用priority</p><p>3.调用<code>shared_ptr</code>构造函数</p><p>这样，如果在调用<code>priority</code>函数的过程中发生了异常，那么调用<code>shared_ptr</code>就不会执行，没放入到智能指针当中去，造成内存泄露。当然你要是头铁不想动脑筋想一个临时变量的名字，<code>make_unique</code>会满足这个需求。</p><h3 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h3><h4 id="删除器使用"><a href="#删除器使用" class="headerlink" title="删除器使用"></a>删除器使用</h4><p>之前有提到过，可以利用RAII的思想，解决互斥锁可能出现忘记解锁的情况。在effective C++中是这样实现的：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex* _mutexPtr)</span>:<span class="hljs-title">mutexPtr</span><span class="hljs-params">(_mutexPtr)</span> </span>&#123;lock(mutexPtr);  <span class="hljs-comment">//构造函数时锁定</span>&#125;~Lock() &#123;unlock(mutexPtr);<span class="hljs-comment">//析构函数解锁</span>&#125;<span class="hljs-keyword">private</span>:Mutex* mutexPtr;&#125;;</code></pre><pre><code class="hljs cpp">Mutex pm;  <span class="hljs-comment">//设置互斥锁</span>Lock(&amp;pm);</code></pre><p>我们传入一个互斥锁，在构造函数加锁，析构函数解锁。看起来也许就是这样的，但是出现赋值操作时，也就是</p><pre><code class="hljs cpp"><span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;pm)</span></span>;<span class="hljs-function">Lock <span class="hljs-title">m2</span><span class="hljs-params">(m1)</span></span>;</code></pre><p>这样的操作会导致多次析构。所以赋值的操作是灾难性的，你可以选择继承<code>private Uncopyable</code>达到无法赋值的效果，也可以使用shared_ptr。但是选择计数器的方式会产生一个问题：传入一个互斥锁的指针，跳出作用域解锁，并且计数器为0，<strong>删除</strong>这个互斥锁。这是我们不想要的。所以无论是unique_ptr还是shared_ptr都可以指定删除器，默认的删除器是delete。</p><p>对上例进行修改</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex* pm)</span>: <span class="hljs-title">mutexPtr</span><span class="hljs-params">(pm,unlock)</span></span>&#123;        lock(mutexPtr.get());    &#125;    <span class="hljs-keyword">private</span>:    <span class="hljs-built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;&#125;</code></pre><h4 id="不要在没有定义的情况下在函数中使用delete"><a href="#不要在没有定义的情况下在函数中使用delete" class="headerlink" title="不要在没有定义的情况下在函数中使用delete"></a>不要在没有定义的情况下在函数中使用delete</h4><p>shared_ptr的删除器比较简单使用，unique_ptr的第二个删除传的是指针，所以一般传递一个函数指针。本来不算吧这个东西放上去的，但是在调试的时候发现一个很有趣的现象:</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span>;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(FB* fb)</span> </span>&#123;<span class="hljs-keyword">delete</span> fb;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数指针&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uni</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FB* fb)</span> </span>&#123;<span class="hljs-keyword">delete</span> fb;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;仿函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FB</span> &#123;</span><span class="hljs-keyword">public</span>:FB(<span class="hljs-keyword">int</span> _k) :k(_k) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;B&#x27;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~FB() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~B&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">int</span> k;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//C++ 11增加的decltype，返回的是类型 </span>unique_ptr&lt;FB, decltype(del)*&gt; ptr1(new FB(2), del);    <span class="hljs-comment">//函数指针</span>unique_ptr&lt;FB, void(*)(FB* )&gt; ptr2(new FB(2), del);    <span class="hljs-comment">//使用仿函数</span>unique_ptr&lt;FB, uni&gt; ptr3(new FB(2));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>跑一下试试</p><pre><code class="hljs cpp">BBB仿函数函数指针函数指针</code></pre><p>发现析构函数没有调用，产生了内存泄露。但是只要把函数或者仿函数放在类的定义之下，或者include “FA.h”,就成功调用了析构函数。</p><p>原因在于，我在前面只声明了FA，但是FA里面有什么成员函数，多大都不知道，是一个不完整类型（Incomplete Type），所以无法触发析构函数。</p><h3 id="为数组设计的智能指针"><a href="#为数组设计的智能指针" class="headerlink" title="为数组设计的智能指针"></a>为数组设计的智能指针</h3><p>STL中没有那种特别为“C++ 动态分配数组”而设计的类似shared_ptr以及unique_ptr的智能指针，原因在于，我们完全可以使用vector等容器来存放这些，所以就完全没有必要。但注意一点是，如果vector中存放的是指针，那么在释放vector的时候不会释放指针指向的资源，此时可以使用智能指针。</p><p>当然如果你痛恨容器或者不屑用它，也可以使用上述的删除器，记得delete[]。</p><p>boost库中提供了这种你需要的东西。boost::scoped_array 和 boost::shared_array </p><h2 id="智能指针的线程安全"><a href="#智能指针的线程安全" class="headerlink" title="智能指针的线程安全"></a>智能指针的线程安全</h2><blockquote><p>引用一下陈硕老师的<a href="https://blog.csdn.net/solstice/article/details/8547547">例子</a></p></blockquote><p>考虑一个简单的场景，有 3 个 shared_ptr<Foo> 对象 x、g、n：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo)</span></span>; <span class="hljs-comment">// 线程之间共享的 shared_ptr</span><span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; x; <span class="hljs-comment">// 线程 A 的局部变量</span><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Foo)</span></span>; <span class="hljs-comment">// 线程 B 的局部变量</span></code></pre><p><img src="https://i.loli.net/2020/10/11/gez5oHSk1yMJabB.png" alt="image-20201009233059869"></p><p><img src="https://i.loli.net/2020/10/11/wBP7ht1ADp5xQ3u.png" alt="image-20201009233139541"></p><p><img src="https://i.loli.net/2020/10/11/WKlz1mXTPNvODcr.png" alt="image-20201009233346743"></p><p>总结一下，shared_ptr的线程不安全性在于他需要操作两个成员，new出来的对象以及计数器。在多线程下，不能保证new出来一个对象一定能被放入shared_ptr中，也不能保证智能指针管理的引用计数的正确性。究其根本，shared_ptr的操作不是一气呵成的。</p><blockquote><ol><li><p>同一个shared_ptr对象可以被多线程同时读取。</p></li><li><p>不同的shared_ptr对象可以被多线程同时修改。</p></li><li><p>同一个shared_ptr对象不能被多线程直接修改，但可以通过原子函数完成。</p></li></ol></blockquote><p>所以在创建一个shared_ptr的时候，使用C++ 11提供的<code>make_shared</code>模板。make_shared创建shared_ptr只申请一次内存，避免了上述错误，也提高了性能。</p><pre><code class="hljs cpp"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p1 = make_shared&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;9&#x27;</span>);   <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2 = make_shared&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p3 = make_shared&lt;<span class="hljs-built_in">string</span>&gt;();</code></pre><p>当需要读写操作时，需要加锁。</p><p>前面提到的unqiue_ptr也是 如此，虽然没有两个成员，但是在申请内存的时候只申请一次。</p><p>总结一下：<br>    在创建智能智能的时候，<strong>使用make_shared以及unique_shared</strong></p><h2 id="QT智能指针"><a href="#QT智能指针" class="headerlink" title="QT智能指针"></a>QT智能指针</h2><p>QT采用的的是半自动的内存管理机制。parent-chlid机制使QOBject类不需要进行delete，当然，是在指定parent的情况下。QT在引入了对象树的概念。当new一个QObject对象的时，指定其父对象，那么这个对象会加入到父对象的对象树之中。<strong>如果父对象被delete，那么子对象也会被delete</strong><br>但是会存在new的类不是QObject类，或者QObject没有指定父对象，QT提供了多种智能指针，相对于STL库中的智能指针，更加强大，或者说更适合QT。</p><h3 id="QSharedPointer-QScopedPointer"><a href="#QSharedPointer-QScopedPointer" class="headerlink" title="QSharedPointer/QScopedPointer"></a>QSharedPointer/QScopedPointer</h3><p>QSharedPointer类似于std::shared_ptr,QScopedPointer类似于std::unique_ptr，用法也是类似的。这边就不再赘述。</p><p>相对的，QT也提供了make_shared的替代，为QSharedPointer制作智能指针，利用完美转发，只分配一次内存。</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> ptr = QSharedPointer&lt;QPushButton&gt;::create(<span class="hljs-string">&quot;Cancel&quot;</span>, <span class="hljs-keyword">this</span>);</code></pre><h3 id="QScopedArrayPointer"><a href="#QScopedArrayPointer" class="headerlink" title="QScopedArrayPointer"></a>QScopedArrayPointer</h3><p>QT也提供了自动释放数组的智能指针</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><span class="hljs-function">  </span>&#123;      <span class="hljs-function">QScopedArrayPointer&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>])</span></span>;      i[<span class="hljs-number">2</span>] = <span class="hljs-number">42</span>;      ...      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// our integer array is now deleted using delete[]</span>  &#125;</code></pre><h3 id="QWeakPointer"><a href="#QWeakPointer" class="headerlink" title="QWeakPointer"></a>QWeakPointer</h3><p>和weak_ptr一样，为了配合QSharedPointer引入的智能指针，有趣的是，曾经QWeakPointer取代过QPointer，但是已经是曾经啦，有兴趣的话可以查看此<a href="https://www.devbean.net/2012/09/continue-using-qpointer/">链接</a></p><h3 id="QSharedDataPointer"><a href="#QSharedDataPointer" class="headerlink" title="QSharedDataPointer"></a>QSharedDataPointer</h3><p>侵入式智能指针，用于进行<strong>隐式共享</strong>。隐式共享会即写时拷贝，常见的例子是string类。他是一个特殊的引用。例如</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<span class="hljs-built_in">string</span> s2=s1;<span class="hljs-built_in">string</span> s2=<span class="hljs-string">&quot;world&quot;</span>;</code></pre><p>在第二行进行赋值操作时，进行的是浅拷贝，共享一个资源。但是在第三行需要进行重新赋值或者修改时，才需要将s1的资源拷贝过来放在s2中，并且修改。</p><p>QSharedDataPointer做的工作类似。需要注意的是，复制过来的只有智能指针管理的资源，而不包括计数器。如果变量超出作用域，也会自动调用析构函数。</p><p>在使用QSharedDataPointer模板时，必须继承QSharedData，实现隐式共享</p><p>例子</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> :</span> <span class="hljs-keyword">public</span> QSharedData&#123;<span class="hljs-keyword">public</span>:    A(QString _str):str(_str)&#123;    &#125;    A(<span class="hljs-keyword">const</span> A&amp; other):QSharedData(other),str(other.str)&#123;    &#125;    QString str;&#125;;</code></pre><pre><code class="hljs cpp">A* a=<span class="hljs-keyword">new</span> A(<span class="hljs-string">&quot;Wathc&quot;</span>);QSharedDataPointer&lt;A&gt;p1(a);<span class="hljs-function">QSharedDataPointer&lt;A&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;p2-&gt;str=<span class="hljs-string">&quot;QCV&quot;</span>;qDebug()&lt;&lt;p1-&gt;str;qDebug()&lt;&lt;p2-&gt;str;</code></pre><pre><code class="hljs cpp">输出<span class="hljs-string">&quot;Wathc&quot;</span><span class="hljs-string">&quot;QCV&quot;</span></code></pre><h3 id="QExplicitlySharedDataPointer"><a href="#QExplicitlySharedDataPointer" class="headerlink" title="QExplicitlySharedDataPointer"></a>QExplicitlySharedDataPointer</h3><p>QExplicitlySharedDataPointer和QSharedPointer相反，他是<strong>显式共享</strong>，需要调用<code>detach()</code>函数，才能写时复制，不然和QSharedPointer一样，使用同一资源。具体用法</p><pre><code class="hljs cpp">QExplicitlySharedDataPointer&lt;A&gt;p1(a);<span class="hljs-function">QExplicitlySharedDataPointer&lt;A&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;p2.detach();p2-&gt;str=<span class="hljs-string">&quot;QCV&quot;</span>;qDebug()&lt;&lt;p1-&gt;str;qDebug()&lt;&lt;p2-&gt;str;</code></pre><pre><code class="hljs cpp">如果加了p2.detach();<span class="hljs-string">&quot;Wathc&quot;</span><span class="hljs-string">&quot;QCV&quot;</span>如果不加<span class="hljs-string">&quot;QCV&quot;</span><span class="hljs-string">&quot;QCV&quot;</span></code></pre><h3 id="QPointer"><a href="#QPointer" class="headerlink" title="QPointer"></a>QPointer</h3><p>QPointer与其他智能指针不同，他只能接受QOBject和QOBject的子类。他在跳出作用域的时候不会自动调用析构函数。如果QOBject类没有指定父类，那么就需要手动Delete。</p><p> 当QPointer<strong>跟踪的对象被析构了以后，任何共享其资源的指针，都会被自动置空</strong>，很好地防止了悬空指针。</p><pre><code class="hljs cpp">QPointer&lt;QPushButton&gt; ptr=<span class="hljs-keyword">new</span> QPushButton;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智能指针</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法(二) Dijkstra算法</title>
    <link href="/WennyAhhh.github.io/2020/10/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E4%BA%8C/"/>
    <url>/WennyAhhh.github.io/2020/10/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径算法（二）-Dijkstra算法"><a href="#最短路径算法（二）-Dijkstra算法" class="headerlink" title="最短路径算法（二）  Dijkstra算法#"></a>最短路径算法（二）  Dijkstra算法#</h1><hr><blockquote><p>数据结构课应该都学过这个算法，采用贪心的策略，适用于两点之间的最短距离</p></blockquote><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>1.选定一个父节点，然后遍历其所有的子节点，那么可以算出：子节点距离=min（已经记录的子节点距离，父节点距离+父节点到子节点的距离）。<br>2.采用一个容器，把上述条件中满足 min中后者条件的节点存进去，遍历结束后，在容器中选出一个最小的距离，并且这个没有被标记过，那么这个距离就应该是原点到这个节点的最短距离，并且标记。<br>3.假设这个距离不是最短的距离，那么这个最短的距离应该早就被取出来标记了。<br>4.就按照这样重复下去，取出来的一定是最短的距离，标记好，并且依靠这个最短的距离不断更新在容器中其他没有标记好的最短距离。<br>5.这个容器可以选择一个最小堆，利用STL库中的优先队列(priority_queue)</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><pre><code class="hljs cpp"><span class="hljs-comment">//v标记，dis储存最短路径</span><span class="hljs-keyword">int</span> v[N],dis[M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; q;<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<span class="hljs-built_in">memset</span>(v,<span class="hljs-literal">false</span>,<span class="hljs-keyword">sizeof</span> v);dis[u]=<span class="hljs-number">0</span>;q.push(&#123;<span class="hljs-number">0</span>,u&#125;);<span class="hljs-keyword">while</span>(!q.empty())&#123;<span class="hljs-keyword">int</span> x=q.top().second;q.pop();<span class="hljs-keyword">if</span>(v[x]) <span class="hljs-keyword">continue</span>;v[x]=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=nex[i])&#123;<span class="hljs-keyword">int</span> j=edge[i],w=weight[i];<span class="hljs-keyword">if</span>(dis[x]+w&lt;dis[j])&#123;dis[j]=dis[x]+w;q.push(&#123;-dis[j],j&#125;);&#125;&#125;&#125;&#125;</code></pre><blockquote><p>时间复杂度从简计算，一个点放进去，通过最小堆再拿出来，需要logn的时间，有n个点，时间复杂度是O(nlogn)。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径算法（一）</title>
    <link href="/WennyAhhh.github.io/2020/10/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E4%B8%80/"/>
    <url>/WennyAhhh.github.io/2020/10/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径算法（一）"><a href="#最短路径算法（一）" class="headerlink" title="最短路径算法（一）"></a>最短路径算法（一）</h1><p>2020/10/2 10:13:30</p><hr><h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><ol><li>在图中，确定一个起点，然后从起点出发到所有点的<strong>最短距离</strong>。</li><li>两点之间存在<strong>负边</strong></li><li>针对整张图来说，<strong>任意两点</strong>之间的距离最短</li></ol><p>针对以上三个问题，有三种算法模板可以使用</p><ul><li>Dijkstra算法</li><li>spfa算法</li><li>Floyd算法</li></ul><h2 id="前置代码"><a href="#前置代码" class="headerlink" title="前置代码"></a>前置代码</h2><p>图的表示方法比较常用的有邻接表和邻接矩阵，都是可行的。一般来说，有时候题目给出的节点值一般为0~n-1，所以在构建图的时候，可以采用一个一维数组来储存。（当然如果不满足调节也可以使用，只不过需要一个映射）</p><p>ps：我们老师讲过节点和结点的概念是不同的，但是文科渣渣以输入法为准。。</p><h3 id="先贴代码"><a href="#先贴代码" class="headerlink" title="先贴代码~"></a>先贴代码~</h3><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1010</span>;   <span class="hljs-comment">//N为节点的数量</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M=N*N+<span class="hljs-number">10</span>; <span class="hljs-comment">//边的数量</span><span class="hljs-keyword">int</span> edge[M],head[N],nex[M],weight[N];<span class="hljs-comment">//edge数组是存储边的</span><span class="hljs-comment">//head数组储存以x节点起点位置</span><span class="hljs-comment">//nex数组将一个点的所有子节点串在一起</span><span class="hljs-comment">//weight权值</span><span class="hljs-keyword">int</span> t;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> w)</span></span>&#123;    edge[++t]=x,weight[N]=w,nex[t]=head[x],head[x]=t;&#125;</code></pre><p>如果需要遍历，比方说从x节点遍历所有的x的子节点</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i;i=nex[i])&#123;<span class="hljs-keyword">int</span> j=edge[i],w=weight[i];<span class="hljs-comment">//j为下一个子节点，w为两点之间的权值</span>......&#125;</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>主要是明白了每个数组的作用，这种储存方式就好解决了</p></blockquote><p>设定一组输入</p><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">10</span><span class="hljs-symbol">0 </span><span class="hljs-number">4</span> <span class="hljs-number">11</span><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">15</span><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">13</span><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">12</span></code></pre><p>一个很简单的树，按照这样的方式，首先由于全局变量所有数组置为0。然后调用add函数，此时的数组为：</p><p><img src="https://i.loli.net/2020/10/02/RcaMh2d8pfU7jDB.png" alt="第一.png"></p><p>然后第二次输入，此时edge[2],应该改为4，nex[2]改为1，head[0]改为2。</p><p><img src="https://i.loli.net/2020/10/02/fyjCNAvZFpuhWl7.png" alt="secon.png"></p><p>由此可见，edge虽然和nex共享一个t，但是edge储存的是真实的子节点，nex中储存的是这个父节点上一个字节点对应的t值。nex数组将一个父节点的全部子节点串起来，head数组储存最后一个子节点，也是所有子节点‘串’的开头。当所有输入完成时，应该是这样的：<br><img src="https://i.loli.net/2020/10/02/uLPtOXavHTxJV49.png" alt="_CN8J4N7_BO~DA_X_01_3D0.png"></p><blockquote><p>注意，题目是无向图的时候，需要调用<strong>两次</strong>,add(x,y,w),add(y,x,w).之前很久没用，血的教训。<br>其实这个东西因为很短，背就完事了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
